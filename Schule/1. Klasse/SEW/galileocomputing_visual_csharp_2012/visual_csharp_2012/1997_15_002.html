<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
      <meta name="title" content="Galileo Computing :: Visual C# 2012 - 15  Multithreading und die Task Parallel Library (TPL)">
      <meta name="author" content="Andreas Kühnel">
      <meta name="publisher" content="Galileo Press">
      <meta name="copyright" content="© Galileo Press, Bonn 2013">
      <meta name="Desription" content="Visual C# 2012 - Das umfassende Handbuch - 15  Multithreading und die Task Parallel Library (TPL)">
      <meta name="robots" content="INDEX,FOLLOW">
      <meta http-equiv="content-language" content="de">
      <title>Galileo Computing :: Visual C# 2012 - 15  Multithreading und die Task Parallel Library
         (TPL)
      </title>
      <link rel="stylesheet" type="text/css" href="common/galileo_open.css">
      <link rel="stylesheet" type="text/css" href="common/prettify.css">
      <link rel="stylesheet" type="text/css" media="screen" href="common/css/lightbox.css"><script type="text/javascript" src="common/js/prototype.js"></script><script src="common/js/scriptaculous.js?load=effects,builder"></script><script type="text/javascript" src="common/js/lightbox.js"></script><link rel="prev" href="15_001.html">
      <link rel="next" href="1997_15_003.html"><script type="text/javascript" src="common/prettify.js"></script><script type="text/javascript" src="common/openwin.js"></script></head>
   <body vlink="#000099" link="#000099" alink="#000099" onload="prettyPrint()">
      <table width="100%" border="0" cellpadding="0" cellspacing="0" bgcolor="#000066">
         <tr>
            <td height="74" valign="bottom" colspan="2"><a href="https://www.galileo-press.de/openbook/?GPP=opvcs"><img src="common/galileocomputing_openbook.gif" width="200" height="56" border="0" alt="Galileo Computing < openbook &gt;" title="Galileo Computing < openbook &gt;"></a></td>
            <td width="80" height="74"><a href="https://www.galileo-press.de/3243/?GPP=opvcs"><img src="common/galileocomputing.gif" border="0" alt="Galileo Computing - Professionelle Bücher. Auch für Einsteiger." title="Galileo Computing - Professionelle Bücher. Auch für Einsteiger."></a></td>
         </tr>
      </table>
      <div align="right"><a href="https://www.galileo-press.de/3243/?GPP=opvcs" class="navnav">Professionelle Bücher. Auch für Einsteiger.</a></div><br><table class="tbl" border="0" cellpadding="0" cellspacing="0" width="100%">
         <tbody>
            <tr>
               <td width="190" valign="top">
                  <table class="tbl1" border="0" cellpadding="3" cellspacing="0" width="190" align="left">
                     <tbody>
                        <tr>
                           <td class="tbl2"><a class="nav" href="index.html">Inhaltsverzeichnis</a></td>
                        </tr>
                        <tr>
                           <td><a class="navnav" href="1997_00_001.html#dodtp98d144f0-bd8d-4de5-8086-32e7ca1478d7"> Vorwort zur 6. Auflage</a></td>
                        </tr>
                        <tr>
                           <td><a class="navnav" href="1997_01_001.html#dodtpf471901b-c92c-4256-b4a7-6c4233f40e97">1  Allgemeine Einführung in .NET</a></td>
                        </tr>
                        <tr>
                           <td><a class="navnav" href="1997_02_001.html#dodtpa6dfd9e4-6ebc-4240-b08a-4dd8e839b1e9">2  Grundlagen der Sprache C#</a></td>
                        </tr>
                        <tr>
                           <td><a class="navnav" href="1997_03_001.html#dodtpf766d18e-5ded-46aa-8e8e-625d86cb0d78">3  Das Klassendesign</a></td>
                        </tr>
                        <tr>
                           <td><a class="navnav" href="1997_04_001.html#dodtp1d1f07d4-0731-4e9c-8de8-d69493f7b393">4  Vererbung, Polymorphie und Interfaces</a></td>
                        </tr>
                        <tr>
                           <td><a class="navnav" href="1997_05_001.html#dodtp3fff44b2-cd1b-47b7-9a94-fbcb259a84b9">5  Delegates und Ereignisse</a></td>
                        </tr>
                        <tr>
                           <td><a class="navnav" href="1997_06_001.html#dodtpaccedd75-eaa3-4322-a479-e04396858096">6  Strukturen und Enumerationen</a></td>
                        </tr>
                        <tr>
                           <td><a class="navnav" href="1997_07_001.html#dodtp77739224-c0d5-4b2a-9a3e-732e2dfca478">7  Fehlerbehandlung und Debugging</a></td>
                        </tr>
                        <tr>
                           <td><a class="navnav" href="1997_08_001.html#dodtp33cf4146-9c07-41aa-b128-fd667a737a33">8  Auflistungsklassen (Collections)</a></td>
                        </tr>
                        <tr>
                           <td><a class="navnav" href="1997_09_001.html#dodtp066354eb-ea00-4a8d-aa5a-fa7bd96e026d">9  Generics &#8211; Generische Datentypen</a></td>
                        </tr>
                        <tr>
                           <td><a class="navnav" href="1997_10_001.html#dodtp077ecd71-a5e8-46be-b6b5-6c31bc77dede">10  Weitere C#-Sprachfeatures</a></td>
                        </tr>
                        <tr>
                           <td><a class="navnav" href="1997_11_001.html#dodtp0c006063-d863-416e-b792-4cc39129b894">11  LINQ</a></td>
                        </tr>
                        <tr>
                           <td><a class="navnav" href="1997_12_001.html#dodtp2bfdab07-505d-4323-9885-77a8e59fa442">12  Arbeiten mit Dateien und Streams</a></td>
                        </tr>
                        <tr>
                           <td><a class="navnav" href="1997_13_001.html#dodtp49638af0-00f8-407f-9740-7dbc1e723fee">13  Binäre Serialisierung</a></td>
                        </tr>
                        <tr>
                           <td><a class="navnav" href="1997_14_001.html#dodtp7327df50-2f94-44ea-8c62-26cb1aae6058">14  XML</a></td>
                        </tr>
                        <tr>
                           <td><a class="navh" href="#dodtp61e706c0-d922-4db1-b2fb-cda3e1ff9a4c">15  Multithreading und die Task Parallel Library (TPL)</a></td>
                        </tr>
                        <tr>
                           <td><a class="navnav" href="1997_16_001.html#dodtp1488d937-efc6-48e5-ba82-1547725215a5">16  Einige wichtige .NET-Klassen</a></td>
                        </tr>
                        <tr>
                           <td><a class="navnav" href="1997_17_001.html#dodtp91f0667a-84db-4a4f-be78-6e8a0d8a3a2c">17  Projektmanagement und Visual Studio 2012</a></td>
                        </tr>
                        <tr>
                           <td><a class="navnav" href="1997_18_001.html#dodtp34972f67-6c1a-406f-a91d-ec8ff67058f9">18  Einführung in die WPF und XAML</a></td>
                        </tr>
                        <tr>
                           <td><a class="navnav" href="1997_19_001.html#dodtp2b691ef2-8859-4650-82c1-efe430ea7070">19  WPF-Layout-Container </a></td>
                        </tr>
                        <tr>
                           <td><a class="navnav" href="1997_20_001.html#dodtp7dad73d4-2c09-421f-a8d4-6a78c0a65acc">20  Fenster in der WPF</a></td>
                        </tr>
                        <tr>
                           <td><a class="navnav" href="1997_21_001.html#dodtp193e3eb8-5130-4640-865a-fcdd743bac28">21  WPF-Steuerelemente</a></td>
                        </tr>
                        <tr>
                           <td><a class="navnav" href="1997_22_001.html#dodtp189c6448-45c3-4ee3-bf41-19ecfa0010d0">22  Elementbindungen</a></td>
                        </tr>
                        <tr>
                           <td><a class="navnav" href="1997_23_001.html#dodtp5183a0da-5247-4a7c-ad83-22accc03224d">23  Konzepte von WPF</a></td>
                        </tr>
                        <tr>
                           <td><a class="navnav" href="1997_24_001.html#dodtp0784a527-2ec1-411a-b5e4-add26ed79abb">24  Datenbindung</a></td>
                        </tr>
                        <tr>
                           <td><a class="navnav" href="1997_25_001.html#dodtp5c4c4699-998d-48a0-b449-ac86d57d6ddb">25  Weitere Möglichkeiten der Datenbindung</a></td>
                        </tr>
                        <tr>
                           <td><a class="navnav" href="1997_26_001.html#dodtp5591376e-61df-4e77-a551-681b9cc62287">26  Dependency Properties</a></td>
                        </tr>
                        <tr>
                           <td><a class="navnav" href="1997_27_001.html#dodtp00fbcc96-1850-421c-a0b4-f4f585913905">27  Ereignisse in der WPF</a></td>
                        </tr>
                        <tr>
                           <td><a class="navnav" href="1997_28_001.html#dodtp0b2d55e9-c350-4f4b-b729-796ab6e638ec">28  WPF-Commands</a></td>
                        </tr>
                        <tr>
                           <td><a class="navnav" href="1997_29_001.html#dodtp3d560bbc-9ede-4881-af9f-d9c24c8c5ae8">29  Benutzerdefinierte Controls</a></td>
                        </tr>
                        <tr>
                           <td><a class="navnav" href="1997_30_001.html#dodtp6f0f9b84-f8f1-405a-b963-d9c64c6cf3d4">30  2D-Grafik</a></td>
                        </tr>
                        <tr>
                           <td><a class="navnav" href="1997_31_001.html#dodtpe8718b27-0d2c-45fd-a030-421a21b5d151">31  ADO.NET &#8211; Verbindungsorientierte Objekte</a></td>
                        </tr>
                        <tr>
                           <td><a class="navnav" href="1997_32_001.html#dodtp5631780e-021d-4716-a880-7604e981153d">32  ADO.NET &#8211; Das Command-Objekt</a></td>
                        </tr>
                        <tr>
                           <td><a class="navnav" href="1997_33_001.html#dodtp3e44ce92-e1cb-4420-9294-a993f673d1e4">33  ADO.NET &#8211; Der SqlDataAdapter</a></td>
                        </tr>
                        <tr>
                           <td><a class="navnav" href="1997_34_001.html#dodtp02622bf1-44a0-453d-828f-5266aea64a96">34  ADO.NET &#8211; Daten im lokalen Speicher </a></td>
                        </tr>
                        <tr>
                           <td><a class="navnav" href="1997_35_001.html#dodtp44f9b504-b660-4f2e-bd26-072f4a498332">35  ADO.NET &#8211; Aktualisieren der Datenbank</a></td>
                        </tr>
                        <tr>
                           <td><a class="navnav" href="1997_36_001.html#dodtpd2ab99b1-a59b-43ef-abb1-e6775e3dddf5">36  Stark typisierte DataSets</a></td>
                        </tr>
                        <tr>
                           <td><a class="navnav" href="1997_37_001.html#dodtp97eab997-f0da-4739-b514-a73fccd2935a">37  Einführung in das ADO.NET Entity Framework</a></td>
                        </tr>
                        <tr>
                           <td><a class="navnav" href="1997_38_001.html#dodtp106a1823-39fd-4557-8819-0e6be4db7cce">38  Datenabfragen des Entity Data Models (EDM)</a></td>
                        </tr>
                        <tr>
                           <td><a class="navnav" href="1997_39_001.html#dodtpcc04d69d-d046-42b7-a6f1-37c7e83c0276">39  Entitätsaktualisierung und Zustandsverwaltung </a></td>
                        </tr>
                        <tr>
                           <td><a class="navnav" href="1997_40_001.html#dodtp6a9ab46f-1f4f-41d8-9ab8-bd419b300904">40  Konflikte behandeln</a></td>
                        </tr>
                        <tr>
                           <td><a class="navnav" href="1997_41_001.html#dodtp160fa133-1df6-4ab9-a622-c56d87121c23">41  Plain Old CLR Objects (POCOs)</a></td>
                        </tr>
                        <tr>
                           <td><a class="navnav" href="stichwort.html">Stichwort</a></td>
                        </tr>
                        <tr>
                           <td><br><a class="navnav"><strong>Download:</strong></a>
                               <br><a href="http://download2.galileo-press.de/openbook/galileocomputing_visual_csharp_2012.zip" class="navnav">- openbook, ca. 26,1 MB</a>
                               <br><a href="http://download2.galileo-press.de/openbook/galileocomputing_visual_csharp_2012_beispiele.zip" class="navnav">- Beispiele, ca. 62,4 MB</a>
                           </td>
                        </tr>
                        <tr>
                           <td><a href="https://www.galileo-press.de/3243/?GPP=opvcs" class="navnav">Buch bestellen</a></td>
                        </tr>
                        <tr>
                           <td><a class="navnav" href="#kommentar">Ihre Meinung?</a><br><br></td>
                        </tr>
                     </tbody>
                  </table>
               </td>
               <td width="10"><img src="common/spacer10.gif" width="10" height="10" alt="Spacer"></td>
               <td width="85%" valign="top">
                  <div style="line-height:100%">
                     <div align="center">
                        <table width="98%" border="0" cellpadding="0" cellspacing="0" bgcolor="#FFFFFF">
                           <tbody>
                              <tr>
                                 <td width="100%" class="start" colspan="1" height="22" align="center">
                                    <table width="100%" border="0" cellspacing="0" cellpadding="0">
                                       <tbody>
                                          <tr>
                                             <td width="25%">
                                                <div align="left"><a href="1997_15_001.html" class="navnav"> &lt;&lt; zurück</a></div>
                                             </td>
                                             <td width="49%">
                                                <div align="center"><a href="https://www.galileo-press.de/3243/?GPP=opvcs" class="navnav">Galileo Computing</a> / <a href="https://www.galileo-press.de/openbook/?GPP=opvcs" class="navnav">
                                                      &lt;openbook&gt;</a> / <a href="index.html" class="navnav">Visual C# 2012</a></div>
                                             </td>
                                             <td width="25%">
                                                <div align="right"><a href="1997_15_003.html" class="navnav">vor &gt;&gt; </a></div>
                                             </td>
                                          </tr>
                                       </tbody>
                                    </table>
                                 </td>
                              </tr>
                              <tr>
                                 <td width="100%" valign="top">
                                    <table width="100%" border="0" cellpadding="10" cellspacing="0" class="box">
                                       <tbody>
                                          <tr>
                                             <td colspan="2"><a href="https://www.galileo-press.de/3243/?GPP=opvcs" class="buchtitel">Visual C# 2012</a><span class="autor"> von Andreas Kühnel</span><br><span class="untertitel">Das umfassende Handbuch</span></td>
                                          </tr>
                                          <tr>
                                             <td valign="top" width="211">
                                                <dl>
                                                   <dt><a href="http://www.galileo-press.de/3243/?GPP=opvcs" class="navnav"><img src="common/9783836219976.png" border="0" alt="Buch: Visual C# 2012" title="Buch: Visual C# 2012"></a></dt>
                                                   <dd><br><a href="http://www.galileo-press.de/3243/?GPP=opvcs"><span class="autor"><strong>Visual C# 2012</strong><br><pressinfo><strong>Galileo Computing</strong><br>1402 S., 6., aktualisierte und erweiterte Auflage 2013, geb., mit DVD<br>49,90 Euro, ISBN 978-3-8362-1997-6
                                                            </pressinfo></span></a></dd>
                                                </dl>
                                             </td>
                                             <td width="80%">
                                                <table border="0">
                                                   <tbody>
                                                      <tr>
                                                         <td valign="baseline"><img src="common/pfeil_u.gif" width="10" height="10" border="0" alt="Pfeil"></td>
                                                         <td valign="baseline" colspan="3" class="kap"><strong><a href="1997_15_001.html#dodtp61e706c0-d922-4db1-b2fb-cda3e1ff9a4c" class="navnav">15 Multithreading und die Task Parallel Library (TPL)</a></strong></td>
                                                      </tr>
                                                      <tr>
                                                         <td valign="baseline" width="10"></td>
                                                         <td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
                                                         <td valign="baseline" colspan="2"><strong><a href="1997_15_001.html#dodtpc0d5936d-a2e4-4b29-9932-e36dbac275af" class="navnav">15.1 Überblick</a></strong></td>
                                                      </tr>
                                                      <tr>
                                                         <td valign="baseline" width="10"></td>
                                                         <td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
                                                         <td valign="baseline" colspan="2"><strong><a href="1997_15_002.html#dodtp4d7cb142-5b23-44cf-8fa5-93084ae61382" class="navh">15.2 Multithreading mit der Klasse »Thread«</a></strong></td>
                                                      </tr>
                                                      <tr>
                                                         <td valign="baseline" width="10"></td>
                                                         <td valign="baseline" width="10"></td>
                                                         <td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
                                                         <td valign="baseline"><strong><a href="1997_15_002.html#dodtp19f119d7-3b77-4536-a049-221ce37cc94d" class="navh">15.2.1 Einführung in das Multithreading</a></strong></td>
                                                      </tr>
                                                      <tr>
                                                         <td valign="baseline" width="10"></td>
                                                         <td valign="baseline" width="10"></td>
                                                         <td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
                                                         <td valign="baseline"><strong><a href="1997_15_002.html#dodtpa66bab0d-2c4f-4309-90e1-f4ea00581c8d" class="navh">15.2.2 Threadzustände und Prioritäten</a></strong></td>
                                                      </tr>
                                                      <tr>
                                                         <td valign="baseline" width="10"></td>
                                                         <td valign="baseline" width="10"></td>
                                                         <td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
                                                         <td valign="baseline"><strong><a href="1997_15_002.html#dodtp1645ee1a-de52-42ca-9683-6fe1993e6641" class="navh">15.2.3 Zusammenspiel mehrerer Threads</a></strong></td>
                                                      </tr>
                                                      <tr>
                                                         <td valign="baseline" width="10"></td>
                                                         <td valign="baseline" width="10"></td>
                                                         <td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
                                                         <td valign="baseline"><strong><a href="1997_15_002.html#dodtp71df3d21-6ccf-44c1-9a44-82e42880cd0e" class="navh">15.2.4 Die Entwicklung einer einfachen Multithreading-Anwendung</a></strong></td>
                                                      </tr>
                                                      <tr>
                                                         <td valign="baseline" width="10"></td>
                                                         <td valign="baseline" width="10"></td>
                                                         <td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
                                                         <td valign="baseline"><strong><a href="1997_15_002.html#dodtpd6a16d11-bd5e-44af-9e14-ac5a11c3eb85" class="navh">15.2.5 Die Klasse »Thread«</a></strong></td>
                                                      </tr>
                                                      <tr>
                                                         <td valign="baseline" width="10"></td>
                                                         <td valign="baseline" width="10"></td>
                                                         <td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
                                                         <td valign="baseline"><strong><a href="1997_15_002.html#dodtp739768cf-b9d9-45cc-a7f6-afa2e8dcf605" class="navh">15.2.6 Threadpools nutzen</a></strong></td>
                                                      </tr>
                                                      <tr>
                                                         <td valign="baseline" width="10"></td>
                                                         <td valign="baseline" width="10"></td>
                                                         <td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
                                                         <td valign="baseline"><strong><a href="1997_15_002.html#dodtp43938eba-7e16-4364-bd85-19b830b86d5c" class="navh">15.2.7 Die Synchronisation von Threads</a></strong></td>
                                                      </tr>
                                                      <tr>
                                                         <td valign="baseline" width="10"></td>
                                                         <td valign="baseline" width="10"></td>
                                                         <td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
                                                         <td valign="baseline"><strong><a href="1997_15_002.html#dodtp8c7e0f11-8034-4e70-83f0-2d8c7626475b" class="navh">15.2.8 Der »Monitor« zur Synchronisation</a></strong></td>
                                                      </tr>
                                                      <tr>
                                                         <td valign="baseline" width="10"></td>
                                                         <td valign="baseline" width="10"></td>
                                                         <td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
                                                         <td valign="baseline"><strong><a href="1997_15_002.html#dodtp8e4a436e-9677-48ce-aacc-f35948ef052f" class="navh">15.2.9 Das Attribut »MethodImpl«</a></strong></td>
                                                      </tr>
                                                      <tr>
                                                         <td valign="baseline" width="10"></td>
                                                         <td valign="baseline" width="10"></td>
                                                         <td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
                                                         <td valign="baseline"><strong><a href="1997_15_002.html#dodtpd46936fd-3a82-40fa-b04d-10ceef675910" class="navh">15.2.10 Das Synchronisationsobjekt »Mutex«</a></strong></td>
                                                      </tr>
                                                      <tr>
                                                         <td valign="baseline" width="10"></td>
                                                         <td valign="baseline" width="10"></td>
                                                         <td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
                                                         <td valign="baseline"><strong><a href="1997_15_002.html#dodtpa9584a73-4980-4804-b6ad-6e098f16b97c" class="navh">15.2.11 Grundlagen asynchroner Methodenaufrufe</a></strong></td>
                                                      </tr>
                                                      <tr>
                                                         <td valign="baseline" width="10"></td>
                                                         <td valign="baseline" width="10"></td>
                                                         <td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
                                                         <td valign="baseline"><strong><a href="1997_15_002.html#dodtp6cd94ef0-9aae-45b1-9de3-f66b3125d6e4" class="navh">15.2.12 Asynchroner Methodenaufruf</a></strong></td>
                                                      </tr>
                                                      <tr>
                                                         <td valign="baseline" width="10"></td>
                                                         <td valign="baseline" width="10"></td>
                                                         <td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
                                                         <td valign="baseline"><strong><a href="1997_15_002.html#dodtp9bd6facd-ddf6-4ead-b467-4f0cdde0ab10" class="navh">15.2.13 Asynchroner Aufruf mit Rückgabewerten</a></strong></td>
                                                      </tr>
                                                      <tr>
                                                         <td valign="baseline" width="10"></td>
                                                         <td valign="baseline" width="10"></td>
                                                         <td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
                                                         <td valign="baseline"><strong><a href="1997_15_002.html#dodtpced1bada-5ac1-498c-9821-5c3fe6e65f9f" class="navh">15.2.14 Eine Klasse mit asynchronen Methodenaufrufen</a></strong></td>
                                                      </tr>
                                                      <tr>
                                                         <td valign="baseline" width="10"></td>
                                                         <td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
                                                         <td valign="baseline" colspan="2"><strong><a href="1997_15_003.html#dodtpcdded817-8f7d-4748-be93-4011e419194f" class="navnav">15.3 Die TPL (Task Parallel Library)</a></strong></td>
                                                      </tr>
                                                      <tr>
                                                         <td valign="baseline" width="10"></td>
                                                         <td valign="baseline" width="10"></td>
                                                         <td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
                                                         <td valign="baseline"><strong><a href="1997_15_003.html#dodtped92ac97-f679-4aee-a6c3-ecb78252bfec" class="navnav">15.3.1 Allgemeines zur Parallelisierung mit der TPL</a></strong></td>
                                                      </tr>
                                                      <tr>
                                                         <td valign="baseline" width="10"></td>
                                                         <td valign="baseline" width="10"></td>
                                                         <td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
                                                         <td valign="baseline"><strong><a href="1997_15_003.html#dodtpc5bc6a6f-61e9-4145-ad44-7442387916a1" class="navnav">15.3.2 Die Klasse »Parallel«</a></strong></td>
                                                      </tr>
                                                      <tr>
                                                         <td valign="baseline" width="10"></td>
                                                         <td valign="baseline" width="10"></td>
                                                         <td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
                                                         <td valign="baseline"><strong><a href="1997_15_003.html#dodtp4e9d3a21-53d2-4140-a0bc-523da641364d" class="navnav">15.3.3 Die Klasse »Task«</a></strong></td>
                                                      </tr>
                                                      <tr>
                                                         <td valign="baseline" width="10"></td>
                                                         <td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
                                                         <td valign="baseline" colspan="2"><strong><a href="1997_15_004.html#dodtp374147ac-0ac9-4355-8e5c-6db6f4543bfc" class="navnav">15.4 Asynchrone Programmierung mit »async« und »await«</a></strong></td>
                                                      </tr>
                                                   </tbody>
                                                </table>
                                             </td>
                                          </tr>
                                       </tbody>
                                    </table>
                                    <table width="100%" cellpadding="20" cellspacing="0" border="0" bgcolor="#eeeeee">
                                       <tbody>
                                          <tr>
                                             <td>
                                                <div class="main"><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a id="dodtp4d7cb142-5b23-44cf-8fa5-93084ae61382" name="dodtp4d7cb142-5b23-44cf-8fa5-93084ae61382"></a><h2 class="t2"><span class="cfett">15.2    </span><span class="cfett"> Multithreading mit der Klasse »Thread«</span><a xmlns="http://www.w3.org/1999/xhtml" href="#dodtp19f119d7-3b77-4536-a049-221ce37cc94d"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></img></a></h2><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a id="dodtp19f119d7-3b77-4536-a049-221ce37cc94d" name="dodtp19f119d7-3b77-4536-a049-221ce37cc94d"></a><h3 class="t3"><span class="cfett">15.2.1    </span><span class="cfett"> Einführung in das Multithreading</span><a xmlns="http://www.w3.org/1999/xhtml" href="#dodtpa66bab0d-2c4f-4309-90e1-f4ea00581c8d"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></img></a><a xmlns="http://www.w3.org/1999/xhtml" href="#dodtp4d7cb142-5b23-44cf-8fa5-93084ae61382"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></img></a></h3>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Stellen Sie sich eine beliebige Anwendung vor, die in der Lage ist, Mails zu versenden.
                                                      Das Versenden kann, wenn die Mail mehrere größere Anhänge hat, durchaus einen längeren
                                                      Zeitraum in Anspruch nehmen. Während des Versendens wird eine Sanduhr angezeigt, und
                                                      der Anwender kann nicht mit der Applikation weiterarbeiten. Erstrebenswert ist es,
                                                      dem Anwender eine Anwendung auszuliefern, die ohne eine Verzögerung auskommt. Dazu
                                                      wäre nur eine Applikation in der Lage, die das <span class="cfett">Multithreading</span><span class="cfett"><a class="indexterm" id="dodtp77accf03-59dc-456e-b608-9ad30df141a3"></a><a class="indexterm" id="dodtp1398bd99-de12-4bf3-aa13-3cd204e3915f"></a></span> beherrscht. Mit einer solchen Anwendung könnte der Benutzer weiterarbeiten, während
                                                      (scheinbar) gleichzeitig die Mail verschickt wird.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Die Entgegennahme der Benutzereingabe und das Versenden der Mail sind zwei Operationen,
                                                      die in einer multithreading-fähigen Anwendung voneinander unabhängig sind und innerhalb
                                                      eines einzigen Prozesses ablaufen. Beide Operationen können dabei dieselben Daten
                                                      benutzen. Jeder Operation wird dazu ein eigener <span class="cfett">Thread</span><span class="cfett"><a class="indexterm" id="dodtp56bbdd15-3f34-482d-b1ee-a6b614695d08"></a><a class="indexterm" id="dodtp5dd44ce8-c3b9-47a1-a883-c42286e950a4"></a><a class="indexterm" id="dodtpb6fe1c67-63cc-4422-b06c-347d3d7d36f5"></a></span> zugeordnet. Ein Thread ist eine Ausführungseinheit und besteht aus einer kontinuierlichen
                                                      Abfolge von Anweisungen. Sie werden weiter unten in den Beispielen noch sehen, wie
                                                      das zu verstehen ist.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Jeder gestarteten Anwendung ist ein Prozess zugeordnet, in dem mindestens ein Thread
                                                      existiert. Somit ist ein Thread die kleinste Ausführungseinheit und gehört im Umkehrschluss
                                                      grundsätzlich immer zu einem Prozess. Wird der letzte Thread eines Prozesses zerstört,
                                                      wird die Laufzeitumgebung der Anwendung beendet. 
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Wenn man eine Ein-Prozessor-Maschine voraussetzt, kann zu einem gegebenen Zeitpunkt
                                                      nur ein Thread von der CPU bearbeitet werden. Stehen mehrere Threads derselben oder
                                                      auch unterschiedlicher Anwendungen zur Ausführung in einer Warteschlange<span class="cfett"><a class="indexterm" id="dodtpfc86a0a1-9693-475b-8b20-52058f139e4c"></a></span>, erfolgt der Austausch der Threads in der CPU in sehr kleinen Zeitintervallen (Standard:
                                                      20 ms). Für die Zuteilung der CPU ist eine Komponente des Systems zuständig, der <span class="cfett">Scheduler</span>. Einem Anwender fällt das nicht auf &#8211; aus seiner Sicht erscheint es so, als würde
                                                      die Ausführung gleichzeitig erfolgen. 
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Im Kontext jedes Threads sind alle Informationen enthalten, um die unterbrochene Ausführung
                                                      zu einem späteren Zeitpunkt wieder problemlos aufnehmen zu können. Dazu gehören die
                                                      Inhalte der CPU-Register zu dem Zeitpunkt, zu dem der Thread den Prozessor verlassen
                                                      hat, sowie alle Informationen, die den Zustand des Threads beschreiben.
                                                   </p><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a id="dodtpa66bab0d-2c4f-4309-90e1-f4ea00581c8d" name="dodtpa66bab0d-2c4f-4309-90e1-f4ea00581c8d"></a><h3 class="t3"><span class="cfett">15.2.2    </span><span class="cfett"> Threadzustände und Prioritäten</span><a xmlns="http://www.w3.org/1999/xhtml" class="indexterm" id="dodtpe135c9d9-5f46-44b6-8acc-f6b6c632e7a3"></a><a xmlns="http://www.w3.org/1999/xhtml" class="indexterm" id="dodtpf21b2305-3424-4eca-a9d9-c6fe6ff32114"></a><a xmlns="http://www.w3.org/1999/xhtml" href="#dodtp1645ee1a-de52-42ca-9683-6fe1993e6641"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></img></a><a xmlns="http://www.w3.org/1999/xhtml" href="#dodtp19f119d7-3b77-4536-a049-221ce37cc94d"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></img></a></h3>
                                                   <h4 class="t4"> Wartende, bereite und laufende Threads</h4>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Jeder Thread kann sich in einem von drei möglichen Zuständen befinden:</p>
                                                   <ul xmlns="http://www.w3.org/1999/xhtml">
                                                      <li class="pgp"><span class="ckursiv">wartend</span><span class="ckursiv"><a class="indexterm" id="dodtp32aad1f0-d533-4464-b74d-1e5c2a950294"></a></span> (waiting)
                                                      </li>
                                                      <li class="pgp"><span class="ckursiv">bereit</span><span class="ckursiv"><a class="indexterm" id="dodtpc82c4149-1671-47e0-a816-241fd88f6f60"></a></span> (ready)
                                                      </li>
                                                      <li class="pgp"><span class="ckursiv">laufend</span><span class="ckursiv"><a class="indexterm" id="dodtp7900ff40-5847-4c3d-a4a3-b8f7ef13d017"></a></span> (running)
                                                      </li>
                                                   </ul>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Ein <span class="cfett">laufender </span>Thread befindet sich aktuell im Prozessor und wird ausgeführt. Ein Prozessor kann
                                                      zu einem gegebenen Zeitpunkt immer nur einen Thread bearbeiten. Nach Ablauf der zugestandenen
                                                      Zeitspanne muss der laufende Thread die CPU räumen. Er reiht sich wieder in die Warteschlange
                                                      auf der Zeitscheibe ein und hofft darauf, dass ihm möglichst schnell wieder Prozessorzeit
                                                      zugeteilt wird.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Die Threads, die in der Warteschlange stehen, werden als <span class="cfett">bereit</span> bezeichnet. Nur einem bereiten Thread kann ein Zeitquantum der CPU zugestanden werden.
                                                      
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Es gibt aber auch Threads, die während ihrer Ausführung freiwillig den Prozessor räumen
                                                      und auch danach zunächst nicht mehr willens sind, sich in die Warteschlange der bereiten
                                                      Threads einzuordnen. Diese Threads werden als <span class="cfett">wartend</span> bezeichnet. Ein wartender Thread muss den Anstoß von einem anderen Thread bekommen,
                                                      um in den bereiten Zustand überführt zu werden.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Bezogen auf einen Prozessor kann sich zu einem gegebenen Zeitpunkt nur ein Thread
                                                      im laufenden Zustand befinden. Die anderen Threads sind entweder <span class="ckursiv">bereit</span> oder <span class="ckursiv">wartend</span>. Der aktuell ausgeführte Thread muss unter folgenden Bedingungen den Prozessor aufgeben:
                                                   </p>
                                                   <ul xmlns="http://www.w3.org/1999/xhtml">
                                                      <li class="pgp">Das ihm zugestandene Zeitquantum ist abgelaufen.</li>
                                                      <li class="pgp">Der Thread muss auf ein anderes Objekt oder eine Benachrichtigung warten. Er tritt
                                                         in den Zustand <span class="ckursiv">wartend</span> ein.
                                                      </li>
                                                      <li class="pgp">Ein anderer Thread mit einer höheren Priorität befindet sich in der Warteschlange.</li>
                                                   </ul>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Während die beiden zuerst aufgeführten Punkte aufgrund der vorherigen Ausführungen
                                                      einleuchtend sein sollten, ist der dritte neu. 
                                                   </p>
                                                   <h4 class="t4"> Threadprioritäten</h4>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Jedem Thread wird eine bestimmte <span class="cfett">Priorität</span> zugeordnet. Stehen mehrere Threads in der Warteschlange, erhält derjenige Thread
                                                      Prozessorzeit, dessen Priorität am höchsten ist. Windows kennt die Prioritätsstufen
                                                      1 bis 31, die allerdings nicht alle genutzt werden. Viele Systemthreads laufen mit
                                                      einer höheren Priorität als die Threads »normaler« Anwendungen. Der Prioritätszuordnung
                                                      eines Threads und den daraus resultierenden Konsequenzen bei der Prozessorzuteilung
                                                      kommt eine sehr große Bedeutung zu. Gäbe es die Zuordnung einer Priorität nicht, wäre
                                                      es unter anderem nicht möglich, aus einer laufenden Windows-Anwendung heraus eine
                                                      andere zu aktivieren. Das System fängt nämlich in einem Thread hoher Priorität den
                                                      Mausklick auf das Fenster einer inaktiven Anwendung ab, ordnet die Mauszeigerposition
                                                      dem direkt darunter liegenden Fenster zu und aktiviert es.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Die Priorität eines Threads kann bei Bedarf erhöht werden. Damit kann man erreichen,
                                                      dass Aufgaben, die Vorrang vor anderen haben sollen, nicht gleichberechtigt mit den
                                                      anderen Threads behandelt werden, sondern bevorzugt. Umgekehrt kann die Priorität
                                                      eines Threads auch verringert werden, um ihn einerseits bereitzuhalten, ihn aber andererseits
                                                      nur in bestimmten Situationen zur Ausführung zu bringen, möglicherweise auch erst
                                                      nach vorheriger Erhöhung der Priorität.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Einen Thread mit niedriger Priorität haben Sie schon kennengelernt: Es ist der Thread
                                                      des <span class="ckursiv">Garbage Collectors</span><span class="ckursiv"><a class="indexterm" id="dodtp55476a04-0f84-47b1-a044-fa3936837463"></a></span>. Dieser erhält erst dann Prozessorzeit, wenn keine andere Ausführungseinheit die
                                                      CPU beansprucht oder die Ressourcen knapp werden. Tritt die letztgenannte Situation
                                                      ein, wird die Priorität des Garbage Collectors angehoben, damit die Speicherbereinigung
                                                      ihre Arbeit verrichten kann.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Ein Thread, dessen Zeit auf der Zeitscheibe abgelaufen ist, wird als <span class="ckursiv">bereit</span> markiert und sichert den Zustand der Daten im Stack. Danach sucht das Betriebssystem
                                                      nach dem Thread, der sowohl als <span class="ckursiv">bereit</span> markiert ist als auch gleichzeitig die höchste Priorität besitzt. Befinden sich mehrere
                                                      bereite Threads auf derselben Prioritätsstufe, weist der Scheduler dem in der Reihenfolge
                                                      stehenden Thread den Prozessor zu.
                                                   </p><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a id="dodtp1645ee1a-de52-42ca-9683-6fe1993e6641" name="dodtp1645ee1a-de52-42ca-9683-6fe1993e6641"></a><h3 class="t3"><span class="cfett">15.2.3    </span><span class="cfett"> Zusammenspiel mehrerer Threads</span><a xmlns="http://www.w3.org/1999/xhtml" href="#dodtp71df3d21-6ccf-44c1-9a44-82e42880cd0e"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></img></a><a xmlns="http://www.w3.org/1999/xhtml" href="#dodtpb73a3097-f676-4349-980d-6e1fdad15374"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></img></a></h3>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Eine multithreading-fähige Anwendung zu schreiben ist nicht einfach und birgt immer
                                                      die latente Gefahr von Fehlern. Eine der größten Fehlerquellen ist der gleichzeitige
                                                      Zugriff mehrerer Komponenten auf eine gemeinsame Ressource. Wartet zum Beispiel ausnahmslos
                                                      jede der beteiligten Komponenten auf die Antwort der anderen, wäre ein <span class="ckursiv">Deadlock</span> die Folge &#8211; die Anwendung kann nicht mehr weiterarbeiten und hängt sich auf. Wir
                                                      können in diesem Kapitel nicht alle Aspekte erörtern, die in diesem Zusammenhang von
                                                      Bedeutung sind. Sie sollten aber immer daran denken, dass mit steigender Anzahl der
                                                      Threads das Gefahrenpotenzial exponentiell steigt, die Komplexität der Anwendung drastisch
                                                      zunimmt und der Ablauf der Anwendung nur noch schwierig nachzuvollziehen ist.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Trotz der Schwierigkeiten, die sich bei der Entwicklung einer Multithreading-Anwendung
                                                      ergeben, gibt es eine Reihe von Situationen, in denen der Einsatz mehrerer Threads
                                                      sinnvoll ist. Meistens handelt es sich um Operationen, die generell eine längere Zeitspanne
                                                      für ihre Ausführung benötigen, z. B. bei der Kommunikation mit anderen Rechnern über
                                                      das Netzwerk oder bei Tasks, die als zeitkritisch eingestuft werden müssen. 
                                                   </p><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a id="dodtp71df3d21-6ccf-44c1-9a44-82e42880cd0e" name="dodtp71df3d21-6ccf-44c1-9a44-82e42880cd0e"></a><h3 class="t3"><span class="cfett">15.2.4    </span><span class="cfett"> Die Entwicklung einer einfachen Multithreading-Anwendung</span><a xmlns="http://www.w3.org/1999/xhtml" href="#dodtpd6a16d11-bd5e-44af-9e14-ac5a11c3eb85"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></img></a><a xmlns="http://www.w3.org/1999/xhtml" href="#dodtp1645ee1a-de52-42ca-9683-6fe1993e6641"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></img></a></h3>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Im folgenden Beispiel wird auf einfachste Weise neben dem Hauptthread, der beim Starten
                                                      einer Anwendung automatisch erzeugt wird, ein zweiter Thread per Programmcode ins
                                                      Leben gerufen. Anhand dieses kleinen Programms wollen wir uns mit den wichtigsten
                                                      Grundlagen einer multithreading-fähigen Anwendung vertraut machen. 
                                                   </p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="listing"><pre class="prettyprint"><span class="clistingfett">// Beispiel: ..\Kapitel 15\EinfacherThread</span><br></br><span class="clistingfett">class Program </span>{<br xmlns="">  <span class="clistingfett">static void Main(string[] args) </span>{<br xmlns="">    ThreadStart del;<br xmlns="">    del = new ThreadStart(TestMethod);<br xmlns="">    Thread thread = new Thread(del);<br></br>    // den zweiten Thread starten<br></br>    thread.Start();<br></br>    for(int i = 0; i &lt;= 100; i++) {<br xmlns="">      for(int k = 1; k &lt;= 20; k++)<br xmlns="">        Console.Write(".");<br xmlns="">      Console.WriteLine("Primär-Thread " + i);<br xmlns="">    }<br xmlns="">    Console.ReadLine();<br xmlns="">  }<br></br>  // diese Methode wird in einem eigenen Thread ausgeführt<br></br><span class="clistingfett">  public static void </span>TestMethod<span class="clistingfett">() </span>{<br xmlns="">    for(int i = 0; i &lt;= 100; i++) {<br xmlns="">      for(int k = 1; k &lt;= 20; k++)<br xmlns="">        Console.Write("X");<br xmlns="">      Console.WriteLine("Sekundär-Thread " + i);<br xmlns="">    }<br xmlns="">  }<br xmlns="">}<br></pre></div>
                                                   <p class="plistingunter"><span xmlns="http://www.w3.org/1999/xhtml" class="nummerierung">Listing 15.1  </span>Einen einfachen Thread erzeugen
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Alle Klassen, die mit der Entwicklung multithreading-fähiger Anwendungen unter .NET
                                                      in Zusammenhang stehen, sind im Namespace <span class="clisting">System.Threading</span><span class="clisting"><a class="indexterm" id="dodtp4d3870b0-36be-4369-9a3f-5c709030cc46"></a></span> zu finden, der am Anfang des Programms mit <span class="clisting">using</span> bekannt gegeben werden sollte. Die wichtigste Klasse innerhalb dieses Namespaces
                                                      dürfte die Klasse <span class="clisting">Thread</span><span class="clisting"><a class="indexterm" id="dodtp87cfeffd-d757-490a-99eb-1d90aa418407"></a></span> sein, mit der ein neuer Thread erzeugt wird. Werfen wir einen Blick auf den eingesetzten
                                                      Konstruktor dieser Klasse:
                                                   </p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="listing"><pre class="prettyprint">public Thread<a class="indexterm" id="dodtp1dd45319-558a-4418-ba2e-c57c530ed2a1"></a>(ThreadStart start); <br></pre></div>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Bei dem Parameter vom Typ <span class="clisting">ThreadStart</span><span class="clisting"><a class="indexterm" id="dodtp02257ff4-7a06-4dca-805c-3c2f27a88a4b"></a></span><span class="cfett"> </span>handelt es sich um einen Delegate, der die Methode angibt, deren Anweisungen in einem
                                                      neuen Thread ausgeführt werden sollen. Die Definition dieses Delegates lautet wie
                                                      folgt:
                                                   </p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="listing"><pre class="prettyprint">public sealed delegate void ThreadStart<a class="indexterm" id="dodtp24947c95-ad4d-4d15-9b19-77572381230f"></a><a class="indexterm" id="dodtp2f3cb5d0-168b-48e4-9540-ab592e3bf85b"></a>();<br></pre></div>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Die Instanz eines Delegates kapselt den Zeiger auf die Speicheradresse einer Methode.
                                                      Die Typen der Parameterliste des Delegates müssen den Typen der Parameterliste der
                                                      Methode entsprechen, auf die der Delegate verweist. Demzufolge kann man dem Konstruktor
                                                      der Klasse <span class="clisting">Thread</span> über den Delegate nur die Adresse einer parameterlosen Methode zuweisen &#8211; in unserem
                                                      Beispiel ist es die Methode <span class="clisting">TestMethod</span>:
                                                   </p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="listing"><pre class="prettyprint">ThreadStart del = new ThreadStart(TestMethod);<br xmlns="">Thread thread = new Thread(del);<br></pre></div>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Im ersten Schritt wird die Variable <span class="ckursiv">del</span> vom Typ des Delegates <span class="clisting">ThreadStart</span> deklariert. Dem Delegate wird die Adresse der benutzerdefinierten Methode übergeben.
                                                      Danach kann die <span class="clisting">Thread</span>-Klasse unter Übergabe der Referenz des Delegates instanziiert werden. Mit
                                                   </p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="listing"><pre class="prettyprint">Thread thread = new Thread(new ThreadStart(TestMethod));<br></pre></div>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">können Sie den Code auch einzeilig formulieren, da die Referenz auf den Delegate nicht
                                                      mehr benötigt wird.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Die Instanziierung der <span class="clisting">Thread</span>-Klasse ist noch nicht ausreichend, um den zweiten Thread der Anwendung zu aktivieren.
                                                      Entscheidend ist vielmehr die Methode <span class="clisting">Start</span> des <span class="clisting">Thread</span>-Objekts:<a class="indexterm" id="dodtp8d02cd13-4398-4afc-8a60-4a2e43a5dded"></a></p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="listing"><pre class="prettyprint">thread.Start<a class="indexterm" id="dodtpf12d28d9-151f-4562-8722-61bb1c8354bb"></a><a class="indexterm" id="dodtpae2ee95a-34ae-480d-b145-6d853b6ba936"></a><a class="indexterm" id="dodtp98c356b5-6a4e-4713-97c8-9813b862082f"></a>();<br></pre></div>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Mit dem Start der Anwendung wird bereits der erste Thread, der Primärthread, automatisch
                                                      erstellt. Der zweite Thread wird erst mit Aufruf von <span class="clisting">Start</span> auf die <span class="clisting">Thread</span>-Referenz zum Leben erweckt. In dem neuen Thread wird <span class="clisting">TestMethod</span> ausgeführt.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Beide Threads arbeiten zwei verschachtelte Schleifen ab. Die Schleifen sind so konstruiert,
                                                      dass eine Zeitscheibeneinheit nicht ausreicht, um jeweils vollständig die Schleifen
                                                      zu durchlaufen, denn dann könnten wir den Effekt des Multithreadings an der Konsole
                                                      nicht erkennen. In der inneren Schleife wird eine Ausgabe in die Konsole geschrieben.
                                                      Beim Primärthread handelt es sich um 20 Punkte pro Schleifendurchlauf, beim Sekundärthread
                                                      sind es jeweils 20-mal der Buchstabe »X«. Daran schließt sich noch die Angabe an,
                                                      welcher Thread für die Ausgabe verantwortlich ist. Darüber hinaus wird der aktuelle
                                                      Zählerstand der äußeren Schleife angehängt.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Schauen wir uns nun die Ausgabe an, die abhängig von der Hardwareausstattung, der
                                                      Systemkonfiguration und anderen laufenden Anwendungen durchaus anders aussehen kann.
                                                      Die Interpretation der Ausgabe hilft, die Arbeitsweise der Threads im Zusammenhang
                                                      mit der Zeitscheibe und der quasiparallelen Ausführung zu verstehen. Auch wenn die
                                                      Anzeige ziemlich chaotisch anmutet, am Ende werden beide Threads ihre Aufgabe vollständig
                                                      erledigt haben.
                                                   </p>
                                                   <p><a href="bilder/15_01.png" rel="lightbox" title="Die Ausgabe der Anwendung »EinfacherThread«"><img class="bild" border="1" src="bilderklein/klein15_01.png" alt="Abbildung"></a></p>
                                                   <p class="pbildunter"><span xmlns="http://www.w3.org/1999/xhtml" class="nummerierung">Abbildung 15.1  </span>Die Ausgabe der Anwendung »EinfacherThread«
                                                   </p>
                                                   <h4 class="t4"> Der Delegate »ParameterizedThreadStart«</h4><a xmlns="http://www.w3.org/1999/xhtml" class="indexterm" id="dodtpf068710d-76a9-4962-9573-e24884401dd1"></a><p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Den Delegate <span class="clisting">ThreadStart</span>, mit dem die in einem separaten Thread laufende Methode beschrieben wird, haben wir
                                                      im vorigen Abschnitt behandelt. <span class="clisting">ThreadStart</span> hat jedoch ein Manko, denn diese Methode muss parameterlos sein. Manchmal ist es
                                                      aber notwendig, der Threadmethode Daten zu übergeben. Dazu wird uns eine Alternative
                                                      mit dem Delegate <span class="clisting">ParameterizedThreadStart</span> geboten:
                                                   </p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="listing"><pre class="prettyprint">public sealed delegate void ParameterizedThreadStart(object obj);<br></pre></div>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Die Instanz eines solchen Delegates kapselt den Zeiger auf eine Methode, die die Referenz
                                                      auf ein beliebiges Objekt erwartet. Hier werden uns alle Türen geöffnet, denn wir
                                                      können, falls mehrere Daten an die Methode übergeben werden sollen, auch ein Array
                                                      oder eine Auflistung angeben.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Die Erzeugung des Threads erfolgt in bekannter Weise. Der einzige Unterschied ist
                                                      im Konstruktor der Klasse <span class="clisting">Thread</span> zu finden, dem wir eine Instanz des Delegaten vom Typ <span class="clisting">ParameterizedThreadStart</span> übergeben:
                                                   </p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="listing"><pre class="prettyprint">Thread thread = new Thread(new ParameterizedThreadStart(ThreadMethod));<br></pre></div>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Um die gewünschten Daten an die Threadmethode zu leiten, greifen wir auf eine Überladung
                                                      der <span class="clisting">Start</span>-Methode zu, der wir das entsprechende Argument mitteilen:
                                                   </p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="listing"><pre class="prettyprint">thread.Start(IrgendEinObjekt);<br></pre></div>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Das übergebene Objekt enthält die Daten, die von der vom Thread ausgeführten Methode
                                                      verwendet werden sollen.
                                                   </p><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a id="dodtpd6a16d11-bd5e-44af-9e14-ac5a11c3eb85" name="dodtpd6a16d11-bd5e-44af-9e14-ac5a11c3eb85"></a><h3 class="t3"><span class="cfett">15.2.5    </span><span class="cfett"> Die Klasse »Thread«</span><a xmlns="http://www.w3.org/1999/xhtml" class="indexterm" id="dodtpd59db48e-a380-4438-8d75-3f79402d8854"></a><a xmlns="http://www.w3.org/1999/xhtml" class="indexterm" id="dodtp851b6b9a-6d67-45ec-b38d-4f3e1f5c69c9"></a><a xmlns="http://www.w3.org/1999/xhtml" href="#dodtp739768cf-b9d9-45cc-a7f6-afa2e8dcf605"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></img></a><a xmlns="http://www.w3.org/1999/xhtml" href="#dodtp6fc7a18e-8ff6-41a1-92db-18163cd09e49"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></img></a></h3>
                                                   <h4 class="t4"> Zugriff eines Threads auf sich selbst</h4>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Ein Thread wird erzeugt, wenn die Klasse <span class="clisting">Thread</span> unter Übergabe eines Delegates instanziiert wird. Dies stellt nicht die einzige Möglichkeit
                                                      dar, sich die Referenz auf einen Thread zu besorgen. Wenn es beispielsweise notwendig
                                                      ist, auf dem Hauptthread Operationen auszuführen, steht Ihnen diese Referenz explizit
                                                      nicht zur Verfügung, da der Thread implizit beim Start der Anwendung erzeugt wird.
                                                      Abhilfe schafft die statische Eigenschaft <span class="clisting">CurrentThread</span>, die eine Referenz auf den aktuellen Thread liefert. Nehmen wir an, dass ein Thread
                                                      seine eigene Priorität mit der Eigenschaft <span class="clisting">Priority</span> erhöhen soll. Dann müssten Sie
                                                   </p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="listing"><pre class="prettyprint">Thread.CurrentThread.Priority = Prioritätswert;<br></pre></div>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">codieren, damit der Thread auf sich selbst zugreifen kann. Auf die Eigenschaft <span class="clisting">Priority</span> kommen wir später zu sprechen.
                                                   </p>
                                                   <h4 class="t4"> Einen Thread für eine bestimmte Zeitdauer anhalten</h4>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Im Beispiel <span class="ckursiv">EinfacherThread</span> wurde eine Schleife konstruiert, um eine kleine Zeitverzögerung zu erreichen. Ohne
                                                      Schleife könnte es sein, dass die gesamte Schleife des ersten Threads bereits vollständig
                                                      abgearbeitet ist, bevor der zweite T<a class="indexterm" id="dodtp83af2c57-3eaf-48f3-a4c1-a76972469f49"></a>hread zum ersten Mal in seine eigene Schleife eintritt. Die <span class="clisting">Thread</span>-Klasse bietet für solche Fälle mit der Methode <span class="clisting">Sleep</span> eine bessere Alternative, um einen Thread für eine bestimmte Zeitdauer anzuhalten
                                                      und damit die Ausführung zu verzögern.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Die Methode ist statisch definiert und kann nicht auf eine bestimmte Threadinstanz
                                                      aufgerufen werden. Der aktuelle Thread zieht sich damit selbst aus dem Verkehr. <span class="clisting">Sleep</span> ist übrigens unabhängig von der Taktfrequenz des Computers. Wird <span class="clisting">Sleep</span> die Zahl 0 übergeben, wird der Thread dazu veranlasst, auf den verbleibenden Rest
                                                      seiner Ausführungszeit zu verzichten und die CPU für den nächsten anstehenden Thread
                                                      frei zu machen. Er reiht sich danach sofort wieder in die Warteschlange ein.
                                                   </p>
                                                   <h4 class="t4"> Sicheres Beenden eines Threads</h4>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Mit der Methode <span class="clisting">Abort</span><span class="clisting"><a class="indexterm" id="dodtp31145e50-c438-4175-bca5-004eb6319777"></a></span><span class="cfett"><a class="indexterm" id="dodtpfd370a86-216d-4546-8288-f4489358ccad"></a><a class="indexterm" id="dodtpaf7f975b-91b6-4dee-ad97-70735bd75848"></a></span> lässt sich ein Thread terminieren. Der Aufruf bewirkt in der Laufzeitschicht die
                                                      Auslösung der Ausnahme <span class="clisting">ThreadAbortException</span><span class="clisting"><a class="indexterm" id="dodtpd179b623-2d71-443f-a394-3a131585be01"></a></span>. Damit ist es möglich, die Methode ordnungsgemäß zu beenden, beispielsweise um dabei
                                                      offene Ressourcen zu schließen.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Dazu zunächst ein Beispiel. Diesmal wird die Routine, die in einem zweiten Thread
                                                      ausgeführt wird, in einer eigenen Klasse definiert. Damit ändert sich grundsätzlich
                                                      nichts, da dem Delegate nun die Adresse der Instanzmethode in der Klasse mitgeteilt
                                                      wird.
                                                   </p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="listing"><pre class="prettyprint"><span class="clistingfett">// Beispiel: ..\Kapitel 15\AbortThread</span><br></br><span class="clistingfett">class Program </span>{<br xmlns="">  <span class="clistingfett">static void Main(string[] args) </span>{<br xmlns="">    Demo obj = new Demo();<br xmlns="">    ThreadStart del = new ThreadStart(obj.TestMethod);<br xmlns="">    Thread thread = new Thread(del);<br xmlns="">    Console.WriteLine("Thread wird jetzt gestartet");<br></br>    // Sekundärthread starten<br></br>    thread.Start();<br xmlns="">    Console.WriteLine("Thread ist gestartet");<br xmlns="">    Thread.Sleep(200);<br></br>    // der sekundäre Thread wird durch den Primärthread mit <br></br>    // der Methode Abort zerstört<br></br>    thread.Abort();<br xmlns="">    Thread.Sleep(100);<br></br>    if (thread.IsAlive)<br xmlns="">      Console.WriteLine("Der Sek.-Thread lebt noch");<br xmlns="">    else<br xmlns="">      Console.WriteLine("Der Sek.-Thread ist aufgegeben");<br xmlns="">    Thread.Sleep(5000);<br xmlns="">  }<br xmlns="">}<br></br><span class="clistingfett">class Demo </span>{<br xmlns="">  <span class="clistingfett">public void TestMethod() </span>{<br xmlns="">    try <br xmlns="">    {<br xmlns="">      Console.WriteLine("Sek.-Thread gestartet.");<br></br>      // die Schleife zwingt Thread eine länger dauernde Ausführung auf<br></br>      for(int i = 0; i &lt;= 100; i++) {<br xmlns="">        Console.WriteLine("Sek.-Thread-Zähler = {0}", i);<br xmlns="">        Thread.Sleep(50);<br xmlns="">      }<br xmlns="">    }<br></br>    catch (ThreadAbortException ex)<br xmlns="">    {<br xmlns="">      Console.WriteLine("Sek.-Thread/im Catch-Block");<br xmlns="">    }<br xmlns="">    finally {<br xmlns="">      Console.WriteLine("Sek.-Thread/in Finally");<br xmlns="">    }<br></br>    Console.WriteLine("Sek.-Thread/nach Finally");<br xmlns="">    for (int i = 0; i &lt;= 20; i++) {<br xmlns="">      Console.Write(".");<br xmlns="">      Thread.Sleep(50);<br xmlns="">    }<br xmlns="">  }<br xmlns="">}<br></pre></div>
                                                   <p class="plistingunter"><span xmlns="http://www.w3.org/1999/xhtml" class="nummerierung">Listing 15.2  </span>Das Beenden eines Threads
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Nach dem Instanziieren der <span class="clisting">Thread</span>-Klasse wird der zweite Thread gestartet. Da wir die <span class="clisting">Abort</span>-Methode testen wollen, müssen wir dafür sorgen, dass <span class="clisting">Abort</span> nicht auf einen Thread trifft, der nicht mehr ausgeführt wird. Deshalb ist in <span class="ckursiv">ThreadExecution</span> der Klasse <span class="clisting">Demo</span> eine Schleife eingebaut, die eine längere Zeit für einen vollständigen Durchlauf
                                                      benötigt. Die Zeit muss so lang angesetzt werden, dass <span class="clisting">Abort</span> auf die noch in Arbeit befindliche Schleife trifft.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Vor dem Aufruf von <span class="clisting">Abort</span> wird der Primärthread zunächst mit <span class="clisting">Sleep</span> gebremst, damit der Sekundärthread etwas Zeit zu arbeiten hat. Nach dem Aufruf von
                                                      <span class="clisting">Abort</span> bekommt das System mit einem zweiten <span class="clisting">Sleep</span>-Aufruf noch Zeit, den Sekundärthread endgültig zu beenden. Durch Auswertung der Eigenschaft
                                                      <span class="clisting">IsAlive</span><span class="clisting"><a class="indexterm" id="dodtp2d4cab94-6fd4-4b93-ab64-b1c80a22dd61"></a><a class="indexterm" id="dodtp2ca5b44b-7251-4e85-8ba9-ea9fc5fd3243"></a><a class="indexterm" id="dodtpcfc9264d-df70-4b87-bff9-70364f2ca328"></a><a class="indexterm" id="dodtpdaabeb8c-4813-4c4c-aec8-709481068a66"></a></span> auf dem Sekundärthread wird festgestellt, ob dieser noch aktiv ist oder nicht. Würden
                                                      wir dem Hauptthread keine Ruhepause gönnen, könnte eine falsche Aussage die Folge
                                                      sein, da die <span class="clisting">if</span>-Bedingungsprüfung vor der Aufgabe des Sekundärthreads durchgeführt wird, weil sich
                                                      <span class="clisting">Abort</span> und <span class="clisting">if</span> innerhalb derselben Zeitscheibe befinden und der freigegebene Thread noch keine Möglichkeit
                                                      erhalten hat, die Ausnahme auszulösen. Die zweite Schleife in der Methode <span class="clisting">TestMethod</span> der Klasse <span class="clisting">Demo</span> soll ebenfalls eine länger andauernde Operation simulieren.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">An der Konsole erfolgt die folgende Ausgabe:</p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="listing"><pre class="prettyprint">Thread wird jetzt gestartet<br xmlns="">Thread ist gestartet<br xmlns="">Sek.-Thread gestartet<br xmlns="">Sek.-Thread-Zähler = 0<br xmlns="">Sek.-Thread-Zähler = 1<br xmlns="">Sek.-Thread-Zähler = 2<br xmlns="">Sek.-Thread-Zähler = 3<br xmlns="">Sek.-Thread/in Catch-Block<br xmlns="">Sek.-Thread/in Finally<br xmlns="">Der Sek.-Thread ist aufgegeben<br></pre></div>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Hier ergibt sich anscheinend ein Widerspruch zu der Aussage in Kapitel 7, dass die
                                                      hinter <span class="clisting">finally</span> stehenden Anweisungen ausgeführt werden: Der Aufruf von <span class="clisting">Abort</span> löst die Exception <span class="clisting">ThreadAbortException</span> aus, aber die zweite Schleife im Sekundärthread wird nicht mehr durchlaufen. Genau
                                                      in diesem Punkt liegt das Besondere dieser Ausnahme, denn sie wird ausgelöst und auch
                                                      abgefangen, aber die Anweisungen hinter dem Ende der Ausnahmebehandlung kommen nicht
                                                      mehr zur Ausführung, da der Thread in diesem Moment bereits terminiert ist. Allerdings
                                                      unterstützt die Laufzeitschicht abschließende Anweisungen in <span class="clisting">finally</span>.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Gegen das außerplanmäßige Beenden kann sich der betroffene Thread allerdings auch
                                                      zur Wehr setzen. Dazu muss im <span class="clisting">catch</span>-Block des Exception Handlers die statische Methode <span class="clisting">Reset</span><span class="clisting">Abort<a class="indexterm" id="dodtpa56324e9-cc9a-4909-9637-5bc2b6317132"></a><a class="indexterm" id="dodtp16ce280d-f50d-493b-9745-6ef97d0408fc"></a></span> aufgerufen werden:
                                                   </p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="listing"><pre class="prettyprint">[...]<br xmlns="">catch (ThreadAbortException e) {<br xmlns="">  Thread.ResetAbort();<br xmlns="">  Console.WriteLine("Sek.-Thread/im Catch-Block");<br xmlns="">  [...]  <br xmlns="">}<br></pre></div>
                                                   <p class="plistingunter"><span xmlns="http://www.w3.org/1999/xhtml" class="nummerierung">Listing 15.3  </span>Einsatz der Methode »ResetAbort«
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Bauen Sie diese Anweisung in den Programmcode des Beispiels ein, wird auch die zweite
                                                      Schleife in <span class="clisting">TestMethod</span> ausgeführt, und die bedingte Prüfung mit <span class="clisting">if</span> führt zu dem Ergebnis, dass der Thread noch lebt &#8211; das allerdings auch nur, weil
                                                      die zweite Schleife ebenfalls wieder eine längere Zeit in Anspruch nimmt oder der
                                                      Thread nicht schon auf normalem Wege aufgegeben worden ist, bevor die Prüfung erfolgt.
                                                   </p>
                                                   <h4 class="t4"> Abhängige Threads &#8211; die Methode »Join«</h4><a xmlns="http://www.w3.org/1999/xhtml" class="indexterm" id="dodtp4eff9876-1ad4-4093-8587-3e1840501545"></a><p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Nun wäre die folgende Ausgangssituation vorstellbar: Der Primärthread beendet den
                                                      Sekundärthread mit <span class="clisting">Abort</span> und muss dabei sicherstellen, dass die Anweisungen im Sekundärthread zuerst vollständig
                                                      abgearbeitet sind, bevor die nächste Anweisung im Primärthread ausgeführt wird. Solche
                                                      Situationen können auftreten, wenn der Code des Primärthreads auf das ordnungsgemäße
                                                      Beenden angewiesen ist. Das heißt aber auch, dass der Aufruf synchron erfolgen muss
                                                      &#8211; dass also auf die quasigleichzeitige Ausführung, die ansonsten die Threads auszeichnet,
                                                      bewusst verzichtet wird.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Wir wollen, um uns der Problematik bewusst zu werden, zunächst eine kleine Änderung
                                                      in <span class="clisting">Main</span> vornehmen. Die Implementierung der Klasse <span class="clisting">Demo</span> bleibt wie im Beispiel <span class="ckursiv">AbortThread</span> erhalten (also ohne den Aufruf von <span class="clisting">ResetAbort</span>, falls Sie damit experimentiert haben sollten).
                                                   </p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="listing"><pre class="prettyprint"><span class="clistingfett">static void Main(string[] args) </span>{<br xmlns="">  Demo obj = new Demo();<br xmlns="">  ThreadStart firstThread;<br xmlns="">  firstThread = new ThreadStart(obj.TestMethod);<br xmlns="">  Thread TheThread = new Thread(firstThread);<br xmlns="">  Console.WriteLine("Thread wird jetzt gestartet");<br></br>  // sekundären Thread starten<br></br>  TheThread.Start();<br xmlns="">  Console.WriteLine("Thread ist gestartet");<br xmlns="">  Console.WriteLine("vor Abort.............");<br></br>  // der sekundäre Thread wird durch den Primärthread mit <br></br>  // der Methode Abort zerstört<br></br>  Thread.Sleep(200);<br xmlns="">  TheThread.Abort();<br></br>  // die folgende Anweisung simuliert Code, der vom Beenden<br></br>  // des Sekundärthreads abhängig ist<br></br>  Console.WriteLine("nach Abort.............");<br xmlns="">  Thread.Sleep(100);<br></br>  if (TheThread.IsAlive)<br xmlns="">    Console.WriteLine("Der Sek.-Thread lebt noch");<br xmlns="">  else<br xmlns="">    Console.WriteLine("Der Sek.-Thread ist aufgegeben");<br xmlns="">  Thread.Sleep(5000);<br xmlns="">}<br></pre></div>
                                                   <p class="plistingunter"><span xmlns="http://www.w3.org/1999/xhtml" class="nummerierung">Listing 15.4  </span>Änderung des Beispielprogramms »ThreadAbort«
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard"><span class="clisting">Main</span> enthält eine Anweisung, die nach dem Aufruf der <span class="clisting">Abort</span>-Methode die Konsolenausgabe 
                                                   </p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="listing"><pre class="prettyprint">nach Abort................<br></pre></div>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">erzwingt. Damit sollen Anweisungen simuliert werden, die auf das ordnungsgemäße Terminieren
                                                      des sekundären Threads angewiesen sind. Sehen wir uns die Konsolenausgabe des Programmcodes
                                                      in Abbildung 15.2 an.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Deutlich ist zu erkennen, dass der sekundäre Thread nach <span class="clisting">Abort</span> immer noch aktiv ist &#8211; die <span class="clisting">catch</span>- und <span class="clisting">finally</span>-Blöcke werden nach der abhängigen Anweisung ausgeführt.
                                                   </p>
                                                   <p><a href="bilder/15_02.png" rel="lightbox" title="Abhängige Threads &#8211; unerwünschter Programmfluss"><img class="bild" border="1" src="bilderklein/klein15_02.png" alt="Abbildung"></a></p>
                                                   <p class="pbildunter"><span xmlns="http://www.w3.org/1999/xhtml" class="nummerierung">Abbildung 15.2  </span>Abhängige Threads &#8211; unerwünschter Programmfluss
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Jetzt hilft eine andere Methode der Klasse <span class="clisting">Thread</span> weiter: <span class="clisting">Join</span>, die den aktuellen, also aufrufenden Thread so lange blockiert, bis der Sekundärthread
                                                      vollständig terminiert ist. Sinnvollerweise wird <span class="clisting">Join</span><span class="clisting"><a class="indexterm" id="dodtpd57b1010-668f-4654-871e-4ec5650d90ed"></a><a class="indexterm" id="dodtp5e465a67-d96f-4231-b01e-90b114a87803"></a></span> direkt hinter <span class="clisting">Abort</span> aufgerufen. Der Programmablauf kehrt erst dann zum Aufrufer zurück, wenn die Threadausführung
                                                      ordnungsgemäß beendet ist.
                                                   </p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="listing"><pre class="prettyprint"><span class="clistingfett">// Beispiel: ..\Kapitel 15\AbhängigerThread</span><br></br><span class="clistingfett">class Program </span>{<br xmlns="">  <span class="clistingfett">static void Main(string[] args) </span>{<br xmlns="">    [...]<br></br>    // der sekundäre Thread wird durch den Primärthread mit <br></br>    // der Methode Abort zerstört<br></br>    Thread.Sleep(200);<br xmlns="">    TheThread.Abort();<br xmlns="">    TheThread.Join();<br></br>    // die folgende Anweisung simuliert Code, der vom <br></br>    // Beenden des Sekundärthreads abhängig ist<br></br>    Console.WriteLine("nach Abort.............");<br xmlns="">    [...]<br xmlns="">  }<br xmlns="">}<br xmlns="">[...]<br></pre></div>
                                                   <p class="plistingunter"><span xmlns="http://www.w3.org/1999/xhtml" class="nummerierung">Listing 15.5  </span>Abhängige Threads 
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Wenn Sie dieses Programm starten, gibt die Konsole das in Abbildung 15.3 gezeigte
                                                      Ergebnis aus.
                                                   </p>
                                                   <p><a href="bilder/15_03.png" rel="lightbox" title="Ausgabe nach dem sicheren Beenden des Threads"><img class="bild" border="1" src="bilderklein/klein15_03.png" alt="Abbildung"></a></p>
                                                   <p class="pbildunter"><span xmlns="http://www.w3.org/1999/xhtml" class="nummerierung">Abbildung 15.3  </span>Ausgabe nach dem sicheren Beenden des Threads
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Wenn wir diese Ausgabe mit der vergleichen, die wir ohne <span class="clisting">Join</span> hatten (Abbildung 15.2), können wir eindeutig erkennen, dass der Thread, dessen Terminierung
                                                      angestoßen wurde, zuerst vollständig abgearbeitet wird, bevor der Aufrufer seinen
                                                      eigenen Programmfluss fortsetzt.
                                                   </p>
                                                   <h4 class="t4"> Threadprioritäten festlegen</h4>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Jeder Thread hat eine Priorität. Mit der Eigenschaft <span class="clisting">Priority</span><span class="clisting"><a class="indexterm" id="dodtpd529f927-5f51-4aad-be79-1c6e7c7baf13"></a><a class="indexterm" id="dodtp3d696b3b-56f3-4ff9-9f6d-e98713ac8a01"></a></span> lässt sich die Priorität eines Threads erhöhen, verringern oder einfach nur auswerten.
                                                      Die Priorität spielt eine entscheidende Rolle bei der Vergabe der Zeitscheibe: Ein
                                                      Thread hat Vorrang vor einem anderen Thread mit niedrigerer Priorität &#8211; vorausgesetzt
                                                      natürlich, dass sich beide durch den Zustand <span class="ckursiv">bereit</span> beschreiben lassen.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard"><span class="clisting">Priority</span><span class="clisting"><a class="indexterm" id="dodtp99ac5935-085a-482a-8821-50da214c8680"></a><a class="indexterm" id="dodtp37750ed1-5327-49cf-b068-a6ffecf80faf"></a></span> ist vom Typ der Enumeration <span class="clisting">ThreadPriority</span><span class="clisting"><a class="indexterm" id="dodtp718d6373-c906-4ded-9969-b7537747482d"></a></span><span class="cfett"><a class="indexterm" id="dodtp049e2a9a-3eb7-4f0b-a0eb-b9c354a87a44"></a><a class="indexterm" id="dodtp0bd84d75-0878-4243-97d6-68688f9bd7e6"></a></span>, die fünf Member definiert: <span class="clisting">Highest, AboveNormal, Normal, BelowNormal, Lowest.</span></p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Die Prioritäten können von der höchsten Stufe (<span class="clisting">Threadpriority.Highest</span>) bis zur niedrigsten (<span class="clisting">ThreadPriority.Lowest</span>) eingestellt werden. Die automatisch einem Thread zugewiesene Priorität lautet <span class="clisting">Normal</span>. 
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Der Thread mit der höchsten Priorität erhält die Zeitscheibe und läuft so lange, bis
                                                      er sich selbst mit <span class="clisting">Sleep</span> einfriert, seine Operationen beendet sind, <span class="clisting">Abort</span> auf ihm aufgerufen wird oder bis ein Thread höherer Priorität lauffähig ist und Anspruch
                                                      auf die CPU erhebt.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Am häufigsten ist der Fall anzutreffen, dass sich mehrere Threads gleicher Priorität
                                                      in die Warteschlange zur CPU eingeordnet haben. Alle erhalten gleiche Zeitanteile
                                                      der CPU nach einem Verfahren, das als <span class="ckursiv">Round-Robin-Verteilungsverfahren</span> bezeichnet wird. Im folgenden Beispielprogramm wollen wir die Auswirkungen der Prioritätsfestlegung
                                                      in einer Anwendung studieren.
                                                   </p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="listing"><pre class="prettyprint"><span class="clistingfett">// Beispiel: ..\Kapitel 15\ThreadPriorität</span><br></br><span class="clistingfett">class Program </span>{<br></br>  // Starten des primären Threads<br></br>  <span class="clistingfett">static void Main(string[] args) </span>{<br xmlns="">    Demo obj = new Demo();<br xmlns="">    Thread thread1, thread2;<br xmlns="">    thread1 = new Thread(new ThreadStart(obj.Execution1));<br xmlns="">    thread2 = new Thread(new ThreadStart(obj.Execution2));<br></br>    // die Priorität von thread1 hochsetzen<br></br>    thread1.Priority = ThreadPriority.AboveNormal;<br></br>    // thread 1 starten<br></br>    thread1.Start();<br></br>    // thread 2 starten<br></br>    thread2.Start();<br xmlns="">    Console.ReadLine();<br xmlns="">  }<br xmlns="">}<br></br><span class="clistingfett">class </span>Demo {<br xmlns="">  <span class="clistingfett">public void Execution1() </span>{<br xmlns="">    for (int i = 0; i &lt;= 500; i++) {<br xmlns="">      Console.Write(".");<br xmlns="">    }<br xmlns="">  }<br></br><span class="clistingfett">  public void Execution2() </span>{<br xmlns="">    for (int number = 0; number &lt;= 10; number++)<br xmlns="">      Console.WriteLine("It's me,Thread2");<br xmlns="">  }<br xmlns="">}<br></pre></div>
                                                   <p class="plistingunter"><span xmlns="http://www.w3.org/1999/xhtml" class="nummerierung">Listing 15.6  </span>Festlegen von Threadprioritäten
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Um den Unterschied deutlich zu machen, empfiehlt es sich, beim ersten Versuch die
                                                      Anweisung zur Erhöhung der Priorität des ersten Threads auszukommentieren. Wenn Sie
                                                      mit dieser Vorgabe die Laufzeitumgebung starten, werden Sie eine Konsolenausgabe erhalten
                                                      (siehe Abbildung 15.4). <span class="ckursiv">thread1</span> wird gestartet, schreibt ein paar Punkte in die Ausgabe und übergibt danach dem Prozessor
                                                      den <span class="ckursiv">thread2</span>, der sich durch eine eigene Zeichenfolge bemerkbar macht. Die Zeitscheibe dauert
                                                      lange genug, um die Anweisungen von <span class="ckursiv">thread2</span> vollständig zu bearbeiten. Danach übernimmt wieder <span class="ckursiv">thread1</span> die CPU und beendet seine Ausführung.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Einem Thread eine gewisse Sonderstellung durch die Erhöhung der Priorität einzuräumen,
                                                      mag vielleicht manchmal ganz verlockend klingen. Bedenken Sie jedoch, dass dieser
                                                      Thread bei einer lang andauernden Operation eine bremsende Wirkung auf die anderen
                                                      Threads hat. Man spricht auch von einem Aushungern des Systems. Gehen Sie daher sorgfältig
                                                      mit dem Erhöhen von Prioritäten um, und achten Sie darauf, dass keine unnötigen Operationen
                                                      von einem solchen Thread ausgeführt werden, sondern nur solche, die für den weiteren
                                                      Ablauf der Anwendung unbedingt notwendig sind.
                                                   </p>
                                                   <p><a href="bilder/15_04.png" rel="lightbox" title="Ausgabe des Beispielprogramms »ThreadPriorität«"><img class="bild" border="1" src="bilderklein/klein15_04.png" alt="Abbildung"></a></p>
                                                   <p class="pbildunter"><span xmlns="http://www.w3.org/1999/xhtml" class="nummerierung">Abbildung 15.4  </span>Ausgabe des Beispielprogramms »ThreadPriorität«
                                                   </p>
                                                   <h4 class="t4"> Vorder- und Hintergrundthreads</h4>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Threads werden in zwei Kategorien unterteilt: in Vorder- und in Hintergrundthreads.
                                                      Ein Prozess wird ausgeführt, solange noch mindestens ein Vordergrundthread<a class="indexterm" id="dodtpbc55d10d-b5c7-42c3-8775-83da9b62908e"></a> existiert. Mit dem Beenden des letzten Vordergrundthreads wird der Prozess der Anwendung
                                                      selbst dann beendet, wenn Hintergrundthreads<a class="indexterm" id="dodtpfc23453e-f9ae-41b7-9c33-5b0f4ab013e7"></a> noch aktiv sind und die ihnen auferlegte Aufgabe noch nicht vollständig ausgeführt
                                                      haben. Das Beenden eines Hintergrundthreads hat im umgekehrten Fall aber nicht zur
                                                      Konsequenz, dass der Vordergrundthread beendet wird.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Die Eigenschaft <span class="clisting">IsBackground</span><span class="clisting"><a class="indexterm" id="dodtp7761bb41-1b36-4fa8-88cd-a8ab516ba79b"></a></span> beschreibt, ob ein Thread als Vorder- oder Hintergrundthread eingestuft ist. Grundsätzlich
                                                      sind alle Threads, die aus der Klasse <span class="clisting">Thread</span> erzeugt werden, zunächst Vordergrundthreads. Mit <span class="clisting">IsBackground</span> lässt sich ein Thread aber auch zu einem Hintergrundthread degradieren.
                                                   </p><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a id="dodtp739768cf-b9d9-45cc-a7f6-afa2e8dcf605" name="dodtp739768cf-b9d9-45cc-a7f6-afa2e8dcf605"></a><h3 class="t3"><span class="cfett">15.2.6    </span><span class="cfett"> Threadpools nutzen</span><a xmlns="http://www.w3.org/1999/xhtml" class="indexterm" id="dodtpf17d4137-a616-4738-bfc9-3ed20a82a82c"></a><a xmlns="http://www.w3.org/1999/xhtml" class="indexterm" id="dodtp28447f86-b255-4601-87a8-0d7efd3b6428"></a><a xmlns="http://www.w3.org/1999/xhtml" href="#dodtp43938eba-7e16-4364-bd85-19b830b86d5c"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></img></a><a xmlns="http://www.w3.org/1999/xhtml" href="#dodtpcf616780-05b7-409b-bb6f-fdfba8eab95b"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></img></a></h3>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Die Arbeit mit mehreren Threads lässt sich durch Threadpools wesentlich vereinfachen,
                                                      denn die Laufzeitumgebung erzeugt eine bestimmte Anzahl von Threads, wenn sie gestartet
                                                      wird. Sie können diese Threads nutzen und brauchen nicht eigens neue zu erzeugen,
                                                      wenn Sie welche benötigen. Nach der Beendigung einer Threadmethode wird der frei gewordene
                                                      Thread in den Pool zurückgeführt und steht anderen Aufgaben zur Verfügung.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Angesprochen wird der Threadpool mit der gleichnamigen Klasse <span class="clisting">Threadpool</span>. Mit deren statischer Methode <span class="clisting">QueueUserWorkItem</span><span class="clisting"><a class="indexterm" id="dodtpf32c40e7-078a-448a-be2f-fc4507dd98a1"></a><a class="indexterm" id="dodtpbce26013-5679-49c9-9f00-509096122819"></a></span> wird der Threadpool aktiviert. Dabei wird der Methode ein Delegate vom Typ <span class="clisting">WaitCallback</span><span class="clisting"><a class="indexterm" id="dodtp1b2a1ca1-c20a-44f4-a3e9-d1835a0ffbb2"></a><a class="indexterm" id="dodtp017056ec-6881-48eb-8595-8063fd14998a"></a></span> übergeben, der die Methode beschreibt, die mit dem Thread ausgeführt werden soll.
                                                      
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Grau ist alle Theorie, daher sehen wir uns zuerst ein komplettes Beispiel an.</p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="listing"><pre class="prettyprint"><span class="clistingfett">// Beispiel: ..\ Kapitel 15\ThreadpoolSample</span><br></br><span class="clistingfett">class Program </span>{<br></br><span class="clistingfett">  static void Main(string[] args) </span>{<br></br>    // den Threadpool erforschen<br></br>    int maxThreads;<br xmlns="">    int asyncThreads;<br xmlns="">    ThreadPool.GetMaxThreads(out maxThreads, out asyncThreads);<br xmlns="">    Console.WriteLine("Max. Anzahl Threads: {0}", maxThreads);<br xmlns="">    Console.WriteLine("Max. Anzahl E/A-Threads: {0}", asyncThreads);<br xmlns="">    Console.WriteLine(new string('-', 40));<br></br>    // Benachrichtigungsereignis, Zustand 'nicht signalisieren'<br></br>    AutoResetEvent ready = new AutoResetEvent(false);<br></br>    // Anfordern eines Threads aus dem Pool<br></br>    ThreadPool.QueueUserWorkItem(new WaitCallback(Calculate), ready);<br xmlns="">    Console.WriteLine("Der Hauptthread wartet ...");<br></br>    // Hauptthread in den Wartezustand setzen<br></br>    ready.WaitOne();<br></br>    Console.WriteLine("Sekundärthread ist fertig.");<br xmlns="">    Console.ReadLine();<br xmlns="">  }<br></br><span class="clistingfett">  public static void Calculate(object obj) </span>{<br xmlns="">    Console.WriteLine("Im Sekundärthread");<br xmlns="">    Thread.Sleep(5000);<br></br>    // Ereigniszustand auf 'signalisieren' festlegen<br></br>    ((AutoResetEvent)obj).Set();<br xmlns="">  }<br xmlns="">}<br></pre></div>
                                                   <p class="plistingunter"><span xmlns="http://www.w3.org/1999/xhtml" class="nummerierung">Listing 15.7  </span>Nutzen des Threadpools
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Die Methode <span class="clisting">Calculate</span> soll in einem Thread aus dem Threadpool ausgeführt werden. Bevor diese Operation
                                                      eingeleitet wird, wollen wir aber noch feststellen, wie viele Threads uns der Pool
                                                      zur Verfügung stellt, und rufen dazu die statische Methode <span class="clisting">GetMaxThreads</span><span class="clisting"><a class="indexterm" id="dodtpf87ec5d2-9a9a-4f13-b277-e758899fdeaf"></a><a class="indexterm" id="dodtpda8c45fd-aa95-4d55-b548-ec38ad98d524"></a></span> auf. Über den ersten Parameter werden uns die Threads geliefert, der zweite Parameter
                                                      gibt darüber hinaus Auskunft über die maximale Anzahl der möglichen E/A-Anforderungen.
                                                      Sie werden feststellen, dass sich 25 Threads im Pool befinden, und zwar pro Prozessor.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Das Beispiel ist so entwickelt, dass nicht nur ein Thread aus dem Pool zur Ausführung
                                                      der Methode <span class="clisting">Calculate</span> herangezogen wird. Darüber hinaus wird auch ein Synchronisationsszenario in Gang
                                                      gesetzt, das bewirkt, dass während der Ausführung von <span class="clisting">Calculate</span> der aufrufende Code in Wartestellung versetzt wird und auf ein Signal von <span class="clisting">Calculate</span> wartet, bevor er seine Arbeit wieder aufnimmt. Mehr zur Synchronisierung erfahren
                                                      Sie im folgenden Abschnitt.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Dem Aufruf der statischen Methode <span class="clisting">QueueUserWorkItem</span> wird ein Delegate übergeben, der die Methode beschreibt, die im Thread ausgeführt
                                                      werden soll. Darüber hinaus kann <span class="clisting">QueueUserWorkItem</span> ein zweites Argument übergeben werden, um der Threadmethode Daten bereitzustellen.
                                                      Hier wird dem zweiten Parameter ein Objekt vom Typ <span class="clisting">AutoResetEvent</span><span class="clisting"><a class="indexterm" id="dodtp63d6899c-5925-4176-a72a-8ccb6bb501f8"></a></span> übergeben. Dieses Objekt versetzt zwei Threads in die Lage, über Signale miteinander
                                                      zu kommunizieren. Erzeugt wird das Objekt im Code mit: 
                                                   </p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="listing"><pre class="prettyprint">AutoResetEvent ready = new AutoResetEvent(false);<br></pre></div>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Der Übergabeparameter <span class="clisting">false</span> besagt, dass der anfängliche Zustand des Objekts auf »nicht signalisiert« festgelegt
                                                      wird. Mit
                                                   </p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="listing"><pre class="prettyprint">ready.WaitOne<a class="indexterm" id="dodtpcb1bbde0-21ba-4e45-9035-c663b99a29a6"></a>();<br></pre></div>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">wird der aktuelle Thread so lange blockiert, bis er ein Signal erhält. Dieses stammt
                                                      aus der Threadmethode und wird durch Aufruf der <span class="clisting">Set</span>-Methode des <span class="clisting">AutoResetEvent</span>-Objekts ausgelöst:
                                                   </p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="listing"><pre class="prettyprint">((AutoResetEvent)obj).Set();<br></pre></div>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Hier profitieren wir davon, dass wir der Threadmethode im zweiten Parameter die Referenz
                                                      auf das <span class="clisting">AutoResetEvent</span> übergeben haben.
                                                   </p><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a id="dodtp43938eba-7e16-4364-bd85-19b830b86d5c" name="dodtp43938eba-7e16-4364-bd85-19b830b86d5c"></a><h3 class="t3"><span class="cfett">15.2.7    </span><span class="cfett"> Die Synchronisation von Threads</span><a xmlns="http://www.w3.org/1999/xhtml" class="indexterm" id="dodtpf8da5012-f7e9-4c95-b76a-9cd525337e78"></a><a xmlns="http://www.w3.org/1999/xhtml" class="indexterm" id="dodtp0f319144-cc92-42d2-b130-f5912571d983"></a><a xmlns="http://www.w3.org/1999/xhtml" href="#dodtp8c7e0f11-8034-4e70-83f0-2d8c7626475b"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></img></a><a xmlns="http://www.w3.org/1999/xhtml" href="#dodtp739768cf-b9d9-45cc-a7f6-afa2e8dcf605"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></img></a></h3>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Solange nur ein Thread eine bestimmte Methode aufruft, hat man die Garantie, dass
                                                      der Code von der ersten bis zur letzten Anweisung durchlaufen wird. Sind mehrere Threads
                                                      im Spiel, könnte einer der Threads eine Methode in einem ungültigen Zustand hinterlassen,
                                                      wenn das System ihm die Zeitscheibe quasi mitten in der Ausführung der Methode entzieht
                                                      und der nächste Thread mit derselben Methode auf demselben Objekt zu arbeiten beginnt.
                                                      Der Thread, der den Objektzustand von seinem Vorgänger übernommen hat, produziert
                                                      dann möglicherweise Ergebnisse, die nicht vorhersehbar und in der Regel auch falsch
                                                      sind.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Hier kommt ein neuer Begriff ins Spiel, der Ihnen vielfach in der Dokumentation zur
                                                      .NET-Klassenbibliothek begegnen wird: die Threadsicherheit.
                                                   </p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="kasten">
                                                      <p class="pbstandard">Unter Threadsicherheit versteht man, dass ein Objekt auch dann in einem gültigen Zustand
                                                         bleibt, wenn mehrere Threads gleichzeitig auf dieselbe Ressource zugreifen. Threadsicher
                                                         bedeutet nichts anderes, als dass mehrere Threads gleichzeitig dieselbe Methode desselben
                                                         Objekts aufrufen dürfen, ohne dass es zu Konflikten kommt.
                                                      </p>
                                                   </div>
                                                   <h4 class="t4"> Unsynchronisierte Threads</h4>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Bevor wir uns mit den Details der Threadsicherheit beschäftigen, wollen wir uns an
                                                      einem Beispiel verdeutlichen, was unter einem ungültigen Zustand zu verstehen ist
                                                      und welche Auswirkungen das haben kann.
                                                   </p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="listing"><pre class="prettyprint"><span class="clistingfett">class Program </span>{<br xmlns="">  <span class="clistingfett">static void Main(string[] args) </span>{<br xmlns="">    Demo obj = new Demo();<br xmlns="">    Thread thread1, thread2;<br xmlns="">    thread1 = new Thread(new ThreadStart(obj.Worker));<br xmlns="">    thread2 = new Thread(new ThreadStart(obj.Worker));<br xmlns="">    thread1.Start();<br xmlns="">    thread2.Start();<br xmlns="">    Console.ReadLine();<br xmlns="">  }<br xmlns="">}<br></br><span class="clistingfett">class Demo </span>{<br xmlns="">  private int value;<br></br><span class="clistingfett">  public void Worker() </span>{<br xmlns="">    while(true) {<br xmlns="">      value++;<br xmlns="">      if (value &gt; 100) break;<br xmlns="">        Console.WriteLine(value);<br xmlns="">    }<br xmlns="">  }  <br xmlns="">}<br></pre></div>
                                                   <p class="plistingunter"><span xmlns="http://www.w3.org/1999/xhtml" class="nummerierung">Listing 15.8  </span>Unsynchronisierte Threads
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Das Projekt enthält zusätzlich zu <span class="clisting">Main</span> noch die Definition der Methode <span class="clisting">Worker</span> in <span class="clisting">Demo</span>. In <span class="clisting">Main</span> werden zwei Threads konstruiert, die beide die Methode <span class="clisting">Worker</span> aufrufen. <span class="clisting">Worker</span> selbst durchläuft eine Schleife, in der die Variable <span class="ckursiv">value</span> hochgezählt und der aktuelle Inhalt an der Konsole ausgegeben wird. Mit dem Endwert
                                                      von 100 wird die Methode wieder verlassen.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Beide Threads greifen auf dasselbe Objekt zu und teilen sich die Arbeit mehr oder
                                                      weniger abwechselnd, um das Feld <span class="ckursiv">value</span> hochzuzählen und dessen Inhalt anzuzeigen. Eigentlich sollte man erwarten, dass die Zahlen chronologisch hintereinander ausgegeben werden, jedoch kommt es an der Konsole beispielsweise zu folgender Ausgabe: 1, 2, 3, 4, ... , 39, 41, 42, 43, ..., 99, 100, 40. Beide Threads greifen unsynchronisiert auf die Variable <span class="ckursiv">value</span> zu, wobei die Operation des ersten Threads mitten in der Schleife unterbrochen wird.
                                                      Dieses ist dem Anschein nach genau der Moment, nachdem der Feldinhalt mit der Anweisung
                                                   </p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="listing"><pre class="prettyprint">value++;<br></pre></div>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">zwar schon auf 40 erhöht, aber mit</p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="listing"><pre class="prettyprint">Console.WriteLine(value);<br></pre></div>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">noch nicht an der Konsole ausgegeben wurde. Der unterbrochene Thread weiß natürlich
                                                      genau, mit welcher Anweisung er seine Arbeit wieder aufnehmen muss, wenn ihm der Scheduler
                                                      wieder Prozessorzeit zuteilt: Er muss zuerst die Zahl 40 ausgeben. Diesen Zwischenstand,
                                                      dessen Informationen durch den Inhalt der CPU-Register beschrieben werden, speichert
                                                      das System im Stack und räumt daraufhin den Prozessor für den nächsten Thread in der
                                                      Warteschlange.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Der zweite Thread, dem anschließend die CPU zugeteilt wird, tritt nun seinerseits
                                                      zum ersten Mal in die Schleife ein, erkennt den aktuell gültigen Feldinhalt der Variablen
                                                      (er beträgt 40), erhöht diesen zunächst auf 41, gibt den Wert aus und setzt die Schleife
                                                      so lange fort, bis seine Zeit abgelaufen ist. Dann verlässt der zweite Thread die
                                                      CPU, das System liest die im Stack gesicherten Daten des ersten Threads in die CPU
                                                      ein und setzt die Arbeit mit genau der Anweisung fort, bei der er unterbrochen wurde:
                                                      mit der Ausgabe der Zahl 40 an der Konsole. 
                                                   </p><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a id="dodtp8c7e0f11-8034-4e70-83f0-2d8c7626475b" name="dodtp8c7e0f11-8034-4e70-83f0-2d8c7626475b"></a><h3 class="t3"><span class="cfett">15.2.8    </span><span class="cfett"> Der »Monitor« zur Synchronisation</span><a xmlns="http://www.w3.org/1999/xhtml" class="indexterm" id="dodtpdad61ca0-2da2-442f-915b-a381b6b8bc5f"></a><a xmlns="http://www.w3.org/1999/xhtml" class="indexterm" id="dodtp88dbff0e-70ff-4d2e-b925-43de9b95baa8"></a><a xmlns="http://www.w3.org/1999/xhtml" class="indexterm" id="dodtpad04d3dc-cda5-4c9e-8600-497f8377d9fc"></a><a xmlns="http://www.w3.org/1999/xhtml" href="#dodtp8e4a436e-9677-48ce-aacc-f35948ef052f"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></img></a><a xmlns="http://www.w3.org/1999/xhtml" href="#dodtpbe349163-53b0-4207-825c-2f7bc5afe99c"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></img></a></h3>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Beide Threads des Beispiels arbeiten ohne Synchronisation und hinterlassen ihrem Nachfolger
                                                      die Ressource in einem ungültigen Zustand. Das wollen wir natürlich vermeiden &#8211; die
                                                      Feldinhalte sollen so ausgegeben werden, dass sie dem tatsächlich aktuellen Stand
                                                      des Feldes entsprechen.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Wenn wir die Arbeitsweise der Methode <span class="clisting">Worker</span> analysieren, stellen wir zu fest, dass ein ganz bestimmter Codeteil als kritisch
                                                      angesehen werden kann. Es sind die beiden Anweisungen:
                                                   </p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="listing"><pre class="prettyprint">value++;<br xmlns="">Console.WriteLine(intVar);<br></pre></div>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Die Ausgabe wird nur dann unseren Erwartungen entsprechen, wenn ein laufender Thread
                                                      seine Ausführung nicht zwischen diesen beiden Anweisungen unterbrechen muss, denn
                                                      zur Erhöhung des Feldwertes gehört auch die Anzeige an der Konsole. Dieser Zusammenhang
                                                      muss für jeden der beiden Threads ersichtlich sein. 
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">An dieser Stelle kommt eine neue Klasse ins Spiel, die die Aufgabe der Synchronisation
                                                      übernimmt: <span class="clisting">Monitor</span><span class="cfett"><a class="indexterm" id="dodtpca8ed51b-45b8-489f-a8e7-50d66e74829e"></a></span>. Mit dieser Klasse lässt sich verhindern, dass mehrere Threads gleichzeitig einen
                                                      bestimmten Codeteil im Programm durchlaufen. Mit anderen Worten bedeutet das, dass
                                                      zu einem Zeitpunkt immer nur ein Thread dieses Codesegment durchlaufen kann. Andere
                                                      Threads, die ebenfalls dieses Codesegment ausführen wollen, müssen warten, bis der
                                                      laufende Thread das Codesegment verlassen hat.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Mit den Methoden <span class="clisting">Enter</span><span class="clisting"><a class="indexterm" id="dodtp732d8fcd-4062-46ba-8d34-8dba15a10746"></a><a class="indexterm" id="dodtp397148f9-7313-4371-8cc1-b6d7bad9d6c4"></a><a class="indexterm" id="dodtp28a6ba58-c57d-4e88-a65e-248ebb48cc05"></a></span> und <span class="clisting">Exit</span><span class="clisting"><a class="indexterm" id="dodtp52fb12c2-2151-4de4-bed4-a33b1cd01285"></a><a class="indexterm" id="dodtp663bbab8-3d9a-4c33-b70b-08c05a4df0ce"></a><a class="indexterm" id="dodtpbbb61e5f-83b3-414b-90b3-835cbada019f"></a></span> der Klasse <span class="clisting">Monitor</span> können kritische Codeabschnitte definiert werden, die zu einem gegebenen Zeitpunkt
                                                      nur von einem Thread betreten werden dürfen. Mit <span class="clisting">Enter</span><span class="clisting"><a class="indexterm" id="dodtp2a1f90dc-1f4c-4123-ad9e-7ca865f57559"></a></span> wird das Codesegment so lange blockiert, bis die Sperrung mit <span class="clisting">Exit</span><span class="clisting"><a class="indexterm" id="dodtp247f276e-de83-4e2f-9de1-be24dc3d9bc1"></a></span> wieder aufgehoben wird. Damit sind ungültige Zustände, die ein Thread hinterlassen
                                                      könnte, wenn ihm die Zeitscheibe entzogen wird, nicht mehr möglich. <span class="clisting">Monitor</span> protokolliert, ob der Vorgängerthread den kritischen Abschnitt mit <span class="clisting">Exit</span> ordnungsgemäß verlassen hat oder nicht.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Sowohl <span class="clisting">Enter</span> als auch <span class="clisting">Exit</span> sind statische Methoden der Klasse <span class="clisting">Monitor</span>. Als Argument wird den beiden Methoden die Referenz auf das zu synchronisierende
                                                      Objekt übergeben, das auch <span class="clisting">this</span> sein darf.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Wir ändern jetzt das Beispiel oben und schaffen die Voraussetzung dafür, dass die
                                                      Zugriffe auf die kritischen Anweisungen synchronisiert erfolgen. Zur Bestätigung lassen
                                                      wir uns diesmal zusätzlich noch den Hashcode des jeweiligen Threads ausgeben, der
                                                      die angezeigte Zahl erzeugt hat. 
                                                   </p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="listing"><pre class="prettyprint"><span class="clistingfett">// Beispiel: ..\Kapitel 15\SynchronisierteThreads</span><br></br>[...]<br></br><span class="clistingfett">class Demo </span>{<br xmlns="">  private int value;<br></br><span class="clistingfett">  public void Worker() {</span><br xmlns="">    while(true) {<br></br>      // Sperre setzen<br></br>      Monitor.Enter(this);<br xmlns="">      value++;<br xmlns="">      if (value &gt; 100) break;<br xmlns="">      Console.WriteLine("Zahl = {0,5} Thread = {1,3}", value,           <br xmlns="">                         Thread.CurrentThread.GetHashCode().ToString());<br xmlns="">      Thread.Sleep(5);<br></br>         // Sperre aufheben<br></br>         Monitor.Exit(this);<br xmlns="">    }<br xmlns="">  }<br xmlns="">}<br></pre></div>
                                                   <p class="plistingunter"><span xmlns="http://www.w3.org/1999/xhtml" class="nummerierung">Listing 15.9  </span>Synchronisation mit der Klasse »Monitor«
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Nun erhalten wir wunschgemäß die Ausgabe der chronologisch geordneten Zahlen von 
                                                      1 bis 100.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Neben der <span class="clisting">Enter</span>-Methode gibt es in der <span class="clisting">Monitor</span>-Klasse noch die Methode <span class="clisting">TryEnter</span>. Diese überprüft zuerst, ob der geschützte Codeabschnitt frei ist, sperrt ihn dann
                                                      und führt den Code aus. Ist das Codesegment jedoch gesperrt, liefert <span class="clisting">TryEnter</span> den Rückgabewert <span class="clisting">false</span>. Darauf kann der Entwickler beispielsweise in einer <span class="clisting">if</span>-Anweisung reagieren.
                                                   </p>
                                                   <h4 class="t4"> Das »lock«-Statement</h4><a xmlns="http://www.w3.org/1999/xhtml" class="indexterm" id="dodtp7a8cbfb3-c725-479b-a9f0-eb9063baf511"></a><p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Neben <span class="clisting">Enter</span> und <span class="clisting">Exit</span> der Klasse <span class="clisting">Monitor</span> gibt es noch eine andere, sprachspezifische Möglichkeit, den Zugriff zu synchronisieren.
                                                      Unter C# ist das die <span class="clisting">l</span><span class="clisting"><a class="indexterm" id="dodtp9661bccc-75c4-4180-ac84-a2abfc9d160f"></a>ock</span>-Anweisung. Die Syntax dazu lautet:
                                                   </p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="listing"><pre class="prettyprint"><span class="clistingfett">lock (</span>Ausdruck<span class="clistingfett">)</span><br></br><span class="clistingfett">{</span><br></br><span class="clistingfett">  // zu synchronisierende Anweisungen</span><br></br><span class="clistingfett">}</span><br></pre></div>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Durch den Anweisungsblock<span class="cfett"> </span>hinter<span class="cfett"> </span><span class="clisting">lock</span> werden die Anweisungen eingeschlossen, die es zu synchronisieren gilt. Dieses Statement
                                                      ist sehr einfach zu handhaben, aber es besitzt nicht die Möglichkeiten, mit denen
                                                      die Klasse <span class="clisting">Monitor</span> ausgestattet ist. 
                                                   </p>
                                                   <h4 class="t4"> Die Methoden »Wait« und »Pulse«</h4><a xmlns="http://www.w3.org/1999/xhtml" class="indexterm" id="dodtpc100f3c3-3310-4d25-9e2a-a6c5d338c26d"></a><a xmlns="http://www.w3.org/1999/xhtml" class="indexterm" id="dodtp6618c279-b507-47a6-a183-2acf34b3c190"></a><a xmlns="http://www.w3.org/1999/xhtml" class="indexterm" id="dodtpd7e9c9f9-1234-439e-a73e-10668153419c"></a><p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Die Klasse <span class="clisting">Monitor</span> ist nicht instanziierbar, da jedem Objekt nur ein Monitor zugeordnet werden kann.
                                                      Mehrere Objekte können den Anspruch auf die Nutzung des Monitors eines anderen Objekts
                                                      erheben, aber nur einem Objekt aus der Warteschlange wird er zugestanden. 
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Stellen Sie sich den Monitor wie ein Fernglas vor, das Sie mit in den Urlaub genommen
                                                      haben, um damit die Landschaft aus der Nähe zu betrachten. Solange Sie das Fernglas
                                                      benutzen, hat keine andere Person die Möglichkeit, die schönen Dinge der Natur aus
                                                      der Nähe zu betrachten. Eine andere Person, die auch einen Blick durch das Fernglas
                                                      werfen möchte, wird sich in die Warteschlange einreihen müssen. Erst wenn Sie das
                                                      Fernglas zur Seite gelegt haben, kann es von einer Person aus der Warteschlange aufgenommen
                                                      werden. Alle anderen Personen müssen sich weiter gedulden.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Nehmen wir jetzt an, Sie wären mit einem Ihrer Freunde im Urlaub. Während Sie durch
                                                      das Fernglas schauen, erhebt auch Ihr Freund darauf Anspruch. Sie legen das Fernglas
                                                      freiwillig zur Seite, informieren Ihren Freund darüber, dass er es nun benutzen darf,
                                                      und treten freiwillig in die Warteschlange.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Die letzten beiden Aktionen lassen sich auch auf den Monitor projizieren. Sobald Sie
                                                      das Fernglas mit der Absicht zur Seite legen, es zu einem späteren Zeitpunkt noch
                                                      einmal zu benutzen, versetzen Sie sich in den Wartezustand und begeben sich in die
                                                      Warteschlange. Die <span class="clisting">Monitor</span>-Klasse beschreibt diese Operation mit der statischen Methode <span class="clisting">Wait</span><span class="cfett"><a class="indexterm" id="dodtp9640d402-2355-47a4-a9ca-9bedc1d81434"></a><a class="indexterm" id="dodtp8ee56845-a8ec-4e76-a522-d6a7502b023c"></a></span>. Das Informieren des nächsten Interessenten in der Warteschlange entspricht der ebenfalls
                                                      statischen Methode <span class="clisting">Pulse</span>. Beide Methoden können nur innerhalb eines Synchronisationsblocks aufgerufen werden.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Mit <span class="clisting">Wait</span> wird der aktuelle Thread blockiert und gleichzeitig die Sperrung des Objekts aufgehoben.
                                                      Damit kann ein anderer Thread das freigegebene Objekt nutzen. Schauen wir uns eine
                                                      Definition der überladenen <span class="clisting">Wait</span>-Methode an:
                                                   </p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="listing"><pre class="prettyprint">public static bool Wait(object obj);<br></pre></div>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Der Parameter nimmt die Referenz auf das Objekt entgegen, dessen Sperrung aufgehoben
                                                      werden soll. Ein wenig sonderbar verhält sich der Rückgabewert. Er ist <span class="clisting">true</span>, wenn kein anderer Thread das Objekt sperrt und der aktuelle Thread selbst die Verantwortung
                                                      der Sperrung übernimmt. Ansonsten kommt kein boolescher Wert zurück, was eine Einreihung
                                                      in die Warteschlange zur Folge hat. Damit bietet sich <span class="clisting">Wait</span> auch dazu an, als Bedingung für den Eintritt in eine Schleife behilflich zu sein:
                                                   </p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="listing"><pre class="prettyprint">while(Monitor.Wait(obj)) {<br></br>  // Thread tritt in den synchronisierten Block ein <br></br>}<br></pre></div>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Es besteht ein großer Unterschied zwischen einem Thread, der mit <span class="clisting">Enter</span> auf den Eintritt in eine synchronisierte Methode wartet, und einem Thread, der sich
                                                      mit <span class="clisting">Wait</span> in den Wartezustand versetzt hat. Ein Thread, der eine synchronisierte Methode mit
                                                      <span class="clisting">Enter</span> betreten möchte, befindet sich im Zustand <span class="ckursiv">bereit</span>. Er reiht sich in die Threads ein, die auf Anweisung des Schedulers hin ein Segment
                                                      der Zeitscheibe erhalten. Ein Thread, der mit <span class="clisting">Wait</span> die Sperrung eines Objekts aufgehoben hat, befindet sich in einer Warteliste &#8211; allerdings
                                                      nicht in der Warteliste, aus der der Scheduler einem <span class="ckursiv">bereiten</span> Thread die CPU zuteilt, sondern in einer Warteliste aller der Threads, die durch
                                                      den Zustand <span class="ckursiv">wartend</span> gekennzeichnet sind.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Um einen Thread aus seinem Wartezustand zu holen, muss ein anderer Thread die Methode
                                                      <span class="clisting">Pulse</span> oder <span class="clisting">PulseAll</span> auf dem gesperrten Objekt aufrufen. Das Problem ist, dass <span class="clisting">Pulse</span> keinen bestimmten wartenden Thread aus der Liste holt, sondern &#8211; falls sich mehrere
                                                      Threads darin befinden &#8211; einen mehr oder weniger willkürlich gewählten, während mit
                                                      <span class="clisting">PulseAll</span><span class="clisting"><a class="indexterm" id="dodtp300c2651-e408-4894-b0ba-1d31ebc72329"></a></span> alle Threads den Zustand <span class="ckursiv">wartend</span> aufgeben und in <span class="ckursiv">bereit</span> übergehen. Damit stehen sie wieder in der Warteschlange der Zeitscheibe &#8211; der Scheduler
                                                      kann ihnen wieder Prozessorzeit zuteilen.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Ein Thread, der mit <span class="clisting">Wait</span> die Sperrung des kritischen Codebereichs aufgehoben hat, wartet auf einen Anstoß
                                                      von außen, um wieder aktiv werden zu können. Er selbst hat keine Möglichkeit, diesen
                                                      Zustand zu beenden. Wenn kein anderer Thread <span class="clisting">Pulse</span> oder <span class="clisting">PulseAll</span> aufruft, wird ein wartender Thread daher niemals mehr laufen können.
                                                   </p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="kasten">
                                                      <p class="pbstandard">Im Extremfall kann der Wartezustand der Threads einer Anwendung zu einem Phänomen
                                                         führen, das unter der Bezeichnung <span class="cfett">Deadlock</span><span class="cfett"><a class="indexterm" id="dodtpc2017408-fa48-4dc7-9453-f1cdf6f0c461"></a><a class="indexterm" id="dodtpecbb0d62-e258-45ed-bf6b-4eb7884a15a4"></a></span> bekannt ist. Dabei befinden sich ausnahmslos alle Threads im blockierten Wartezustand.
                                                         Die Anwendung hängt sich in diesem Moment auf.
                                                      </p>
                                                   </div>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Wir wollen nun die vorgestellten Methoden in einem Beispiel testen. Dazu werden wir
                                                      ein Programm entwickeln, das in Lage ist, Zahlen zu erzeugen. Das ist eigentlich nichts
                                                      Weltbewegendes, und wir haben auch schon in den anderen Beispielen Zahlen erzeugt.
                                                      Das Besondere ist jedoch, dass jede Zahl genau einmal von einem Verbraucher ausgewertet
                                                      werden soll. Der Verbrauch soll durch eine Konsolenausgabe simuliert werden. Erzeuger
                                                      und Konsument sollen in einem eigenen Thread laufen.
                                                   </p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="listing"><pre class="prettyprint"><span class="clistingfett">// Beispiel: ..\ Kapitel 15\Zahlenkonsument</span><br></br><span class="clistingfett">class Program</span> {<br xmlns="">  public static bool finished = false;<br xmlns="">  public static bool thread1Waiting = false;<br xmlns="">  public static bool thread2Waiting = false;<br></br><span class="clistingfett">  static void Main(string[] args) </span>{<br xmlns="">    MyNumber zahl = new MyNumber();<br xmlns="">    ProduceNumber prod = new ProduceNumber(zahl);<br xmlns="">    ConsumeNumber cons = new ConsumeNumber(zahl);<br xmlns="">    Thread thread1, thread2;<br></br>    // Threads instanziieren<br></br>    thread1 = new Thread(new ThreadStart(prod.MakeNumber));<br xmlns="">    thread2 = new Thread(new ThreadStart(cons.GetNumber));<br></br>    // Threads starten<br></br>    thread1.Start();<br xmlns="">    thread2.Start();<br xmlns="">    Console.ReadLine();<br xmlns="">  }<br xmlns="">}<br></br>// ------ erzeugt eine Zahl ------------<br></br><span class="clistingfett">class ProduceNumber </span>{<br xmlns="">  private MyNumber obj;<br></br><span class="clistingfett">  public ProduceNumber(MyNumber obj) </span>{<br xmlns="">    this.obj = obj;<br xmlns="">  }<br></br>  <span class="clistingfett">public void MakeNumber()</span> {<br xmlns="">    Random rnd = new Random();<br xmlns="">    Monitor.Enter(obj);<br xmlns="">    for (int i = 0; i &lt;= 10; i++) {<br xmlns="">      Program.thread1Waiting = true;<br></br>      // falls der Konsumerthread noch nicht im Wartezustand ist,<br></br>      // selbst in den Wartezustand gehen<br></br>      if(Program.thread2Waiting == false) <br xmlns="">        Monitor.Wait(obj);<br xmlns="">      obj.Number = rnd.Next(0, 1000);<br xmlns="">      Console.WriteLine("Nummer {0} erzeugt", obj.Number);<br></br>      // dem nächsten in der Warteschlange stehenden Objekt<br></br>      // den Monitor übergeben<br></br>      Monitor.Pulse(obj);<br xmlns="">      Program.thread2Waiting = false;<br xmlns="">    }<br xmlns="">    Program.finished = true;<br xmlns="">    Monitor.Exit(obj);<br xmlns="">  }<br xmlns="">} <br></br>// --------- verbraucht eine Zahl -------------<br></br><span class="clistingfett">class ConsumeNumber </span>{<br xmlns="">  private MyNumber obj;<br></br><span class="clistingfett">  public ConsumeNumber(MyNumber obj) </span>{<br xmlns="">    this.obj = obj;<br xmlns="">  }<br></br><span class="clistingfett">  public void GetNumber() </span>{<br xmlns="">    Monitor.Enter(obj);<br></br>    // wenn sich der Erzeugerthread im Wartezustand<br></br>    // befindet, ihn 'bereit' schalten<br></br>    if(Program.thread1Waiting)<br xmlns="">      Monitor.Pulse(obj);<br></br>    Program.thread2Waiting = true; <br></br>    while(Monitor.Wait(obj)) { <br xmlns="">      Console.WriteLine("Nummer {0} verbraucht",obj.Number);<br xmlns="">      Monitor.Pulse(obj);<br xmlns="">      if(Program.finished) Thread.CurrentThread.Abort();<br xmlns="">    }<br xmlns="">    Monitor.Exit(obj);<br xmlns="">  }<br xmlns="">}<br></br>// ------------ repräsentiert eine Zahl -------------------<br></br><span class="clistingfett">class MyNumber </span>{<br xmlns="">  private int intValue;<br></br><span class="clistingfett">  public int Number </span>{<br xmlns="">    get {return intValue;}<br xmlns="">    set {intValue = value;}<br xmlns="">  }<br xmlns="">}<br></pre></div>
                                                   <p class="plistingunter"><span xmlns="http://www.w3.org/1999/xhtml" class="nummerierung">Listing 15.10  </span>Synchronisation zweier Threads
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Der Kern der Anwendung wird durch die beiden Klassen <span class="clisting">ProduceNumber</span> und <span class="clisting">ConsumeNumber</span> beschrieben. <span class="clisting">ProduceNumber</span> erzeugt mit der Methode <span class="clisting">MakeNumber</span> auf Basis des Zufallszahlengenerators Zahlen zwischen 0 und 999 und schreibt diese
                                                      in das Feld eines Objekts vom Typ der Klasse <span class="clisting">MyNumber</span>, das in <span class="clisting">Main</span> erzeugt wird und dessen Referenz den Konstruktoren der Klassen <span class="clisting">ConsumeNumber</span> und <span class="clisting">ProduceNumber</span> übergeben wird. Damit ist sichergestellt, dass sowohl der Erzeuger als auch der Verbraucher
                                                      mit demselben <span class="clisting">MyNumber</span>-Objekt operieren.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Betrachten wir nun die prinzipielle Arbeitsweise des Verbrauchers und des Konsumenten
                                                      unter der Prämisse, dass zuerst der Erzeugerthread und danach der Verbraucherthread
                                                      gestartet wird. Der gesamte Code in der Routine <span class="clisting">MakeNumber</span> ist synchronisiert. Insgesamt werden elf Zahlen in einer Schleife erzeugt. Direkt
                                                      nach dem Schleifeneintritt wird die <span class="clisting">Wait</span>-Methode des Monitors aufgerufen und die Sperre des Objekts vom Typ <span class="clisting">MyNumber</span> aufgehoben. Jetzt kann ein anderer Thread auf das freigegebene <span class="clisting">MyNumber</span>-Objekt zugreifen und die Zahl »verbrauchen«, die im Schleifendurchlauf zuvor erzeugt
                                                      worden ist. Der Erzeugerthread verharrt so lange in Wartestellung, bis der Verbraucherthread
                                                      <span class="clisting">Pulse</span> aufruft und den Erzeugerthread wieder in den Zustand <span class="ckursiv">bereit</span> versetzt. Ist dessen Wartezustand aufgehoben, wird die nächste Zahl erzeugt. Bevor
                                                      der nächste Schleifendurchlauf ausgeführt wird, wird der Verbraucher mit <span class="clisting">Pulse</span> in den Zustand <span class="ckursiv">bereit</span> erhoben.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">In der Methode <span class="clisting">GetNumber</span> des Verbrauchers ist der Programmcode ebenfalls synchronisiert. Direkt nach dem Eintritt
                                                      in den Synchronisierungsabschnitt wird <span class="clisting">Pulse</span> aufgerufen, um den wartenden Erzeugerthread nach dem Start der Anwendung in den Zustand
                                                      <span class="ckursiv">bereit</span> zu versetzen. Anschließend ruft der Konsument <span class="clisting">Wait</span> auf. Damit wird der Monitor des Objekts an den Erzeuger weitergegeben, der eine Zahl
                                                      erzeugt. Gibt der Erzeuger die Sperre an den Konsumenten zurück, wird die neue Zahl
                                                      zuerst an der Konsole angezeigt und anschließend <span class="clisting">Pulse</span> aufgerufen. Jetzt ist der Erzeugerthread wieder im Zustand <span class="ckursiv">bereit</span>, während der Konsument seinerseits anschließend den Monitor freigibt und sich in
                                                      den Wartezustand versetzt. 
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Damit der Verbraucherthread überhaupt erfährt, wann der Erzeuger die letzte Zahl bereitgestellt
                                                      hat, ist die boolesche Variable <span class="ckursiv">finished</span> in <span class="clisting">Program</span> deklariert, die vom Erzeuger nach dem letzten Schleifendurchlauf auf <span class="clisting">true</span> gesetzt wird.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">So viel zur prinzipiellen Arbeitsweise. Es gibt aber noch ein Problem, dem wir bisher
                                                      noch keine Beachtung geschenkt haben: Wir können nämlich nicht garantieren, dass der
                                                      Erzeugerthread als Erstes gestartet wird. Erhält nach dem Starten der Anwendung der
                                                      Konsument vor dem Erzeuger die CPU, würde es zu einem klassischen Deadlock kommen,
                                                      wenn sich beide Threads gleichzeitig im Zustand <span class="ckursiv">wartend</span> befinden. Wir müssen also eine genaue Steuerung des Programmablaufs in der Weise
                                                      erzwingen, dass sich der Verbraucherthread im Wartezustand befindet, wenn die erste
                                                      Zahl erzeugt wird. Diese Steuerung wird über die beiden booleschen Variablen <span class="ckursiv">thread1Waiting</span> und <span class="ckursiv">thread2Waiting</span> erreicht, deren Auswertung garantiert, dass sich &#8211; unabhängig von der Startreihenfolge
                                                      &#8211; zu einem gegebenen Zeitpunkt immer nur ein Thread im Wartezustand befindet.
                                                   </p>
                                                   <p><a href="bilder/15_05.png" rel="lightbox" title="Die Ausgabe des Beispielprogramms »Zahlenkonsument«"><img class="bild" border="1" src="bilderklein/klein15_05.png" alt="Abbildung"></a></p>
                                                   <p class="pbildunter"><span xmlns="http://www.w3.org/1999/xhtml" class="nummerierung">Abbildung 15.5  </span>Die Ausgabe des Beispielprogramms »Zahlenkonsument«
                                                   </p><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a id="dodtp8e4a436e-9677-48ce-aacc-f35948ef052f" name="dodtp8e4a436e-9677-48ce-aacc-f35948ef052f"></a><h3 class="t3"><span class="cfett">15.2.9    </span><span class="cfett"> Das Attribut »MethodImpl«</span><a xmlns="http://www.w3.org/1999/xhtml" class="indexterm" id="dodtp0e9c65c0-1c0c-45b6-841f-00ad05d5b177"></a><a xmlns="http://www.w3.org/1999/xhtml" class="indexterm" id="dodtpc2a5d72d-11d8-41cb-9ab8-f10182fcaa8e"></a><a xmlns="http://www.w3.org/1999/xhtml" href="#dodtpd46936fd-3a82-40fa-b04d-10ceef675910"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></img></a><a xmlns="http://www.w3.org/1999/xhtml" href="#dodtpf9e53f54-a96f-42be-bf20-fb2b447a5390"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></img></a></h3>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Es gibt noch eine weitere Alternative, um die Synchronisierung zwischen mehreren Threads
                                                      zu erzielen: mit dem Attribut <span class="clisting">MethodImpl</span>. Die zugrunde liegende Klasse ist im Namespace <span class="clisting">System.Runtime.CompilerServices</span> zu finden. Das Attribut kann nur auf Konstruktoren und Methoden angewendet werden.
                                                      Es ersetzt die Klasse <span class="clisting">Monitor</span> mit dem Unterschied, dass nicht nur ein bestimmtes Codesegment eingehüllt wird, sondern
                                                      in einem Zug gleich die gesamte Methode. Somit kann auch immer nur ein Thread zu einem
                                                      bestimmten Zeitpunkt diese Methode ausführen. Dazu ein Beispiel:
                                                   </p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="listing"><pre class="prettyprint">[MethodImpl(MethodImplOptions.Synchronized)]<span class="clistingfett"><br xmlns="">public void Calculate()</span> {<br></br>  // Anweisungen<br></br>}<br></pre></div>
                                                   <p class="plistingunter"><span xmlns="http://www.w3.org/1999/xhtml" class="nummerierung">Listing 15.11  </span>Synchronisation mit dem Attribut »MethodImplAttribute«
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Dem Attribut <span class="clisting">MethodImpl</span> können verschiedene Parameter übergeben werden. Zur Synchronisation verwenden Sie
                                                      <span class="clisting">MethodImplOptions.Synchronized</span>. 
                                                   </p><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a id="dodtpd46936fd-3a82-40fa-b04d-10ceef675910" name="dodtpd46936fd-3a82-40fa-b04d-10ceef675910"></a><h3 class="t3"><span class="cfett">15.2.10    </span><span class="cfett"> Das Synchronisationsobjekt »Mutex«</span><a xmlns="http://www.w3.org/1999/xhtml" class="indexterm" id="dodtp06349738-da9a-4a95-a02d-8abd6c03d2ea"></a><a xmlns="http://www.w3.org/1999/xhtml" class="indexterm" id="dodtpb9b63de1-b06f-4499-9102-3354f18cd40d"></a><a xmlns="http://www.w3.org/1999/xhtml" href="#dodtpa9584a73-4980-4804-b6ad-6e098f16b97c"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></img></a><a xmlns="http://www.w3.org/1999/xhtml" href="#dodtp8e4a436e-9677-48ce-aacc-f35948ef052f"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></img></a></h3>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Die Klasse <span class="clisting">Monitor</span> eignet sich nur zur Synchronisation von Threads, die innerhalb eines Prozessraums
                                                      laufen. Manchmal müssen Abläufe aber auch über Prozessgrenzen hinweg synchronisiert
                                                      werden. In diesen Fällen müssen Sie die Klasse <span class="clisting">Mutex</span> einsetzen. Ich möchte Ihnen hierzu ein Beispiel zeigen, bei dem ein <span class="clisting">Mutex</span>-Objekt dazu benutzt wird, zu verhindern, dass eine Anwendung mehrfach gestartet werden
                                                      kann.
                                                   </p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="listing"><pre class="prettyprint"><span class="clistingfett">// Beispiel: ..\Kapitel 15\MutexSample</span><br></br><span class="clistingfett">class Program </span>{<br xmlns="">  private static Mutex mutex;<br></br><span class="clistingfett">  static void Main(string[] args) </span>{<br xmlns="">    if (IsApplicationStarted()) {<br xmlns="">      Console.WriteLine("Die Anwendung wurde bereits gestartet");<br xmlns="">      Console.WriteLine("Ein zweiter Start ist nicht möglich.");<br xmlns="">    }<br xmlns="">    else {<br xmlns="">      Console.WriteLine("Die Anwendung wird gestartet.");<br xmlns="">      Console.WriteLine("Die Anwendung läuft.");<br xmlns="">    }<br xmlns="">    Console.ReadLine();<br xmlns="">  }<br></br><span class="clistingfett">  public static bool IsApplicationStarted() </span>{<br xmlns="">    string mutexName = Application.ProductName;<br xmlns="">    mutex = new Mutex(false, mutexName);<br xmlns="">    if (mutex.WaitOne(0, true))<br xmlns="">      return false;<br xmlns="">    else<br xmlns="">      return true;<br xmlns="">  } <br xmlns="">}<br></pre></div>
                                                   <p class="plistingunter"><span xmlns="http://www.w3.org/1999/xhtml" class="nummerierung">Listing 15.12  </span>Einsatz eines Mutex
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Ein Mutex ist ein einfaches Systemobjekt und durch einen eindeutigen Namen gekennzeichnet.
                                                      Ein <span class="clisting">Mutex</span>-Objekt gestattet nur jeweils einem Thread exklusiven Zugriff auf die gemeinsam genutzte
                                                      Ressource. In unserem Beispiel wird das die Anwendung selbst sein. Wenn ein Thread
                                                      ein <span class="clisting">Mutex</span>-Objekt erhält, wird ein zweiter Thread, der dieses Objekt abruft, so lange angehalten,
                                                      bis der erste Thread das <span class="clisting">Mutex</span>-Objekt freigibt.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Die Klasse <span class="clisting">Mutex</span> stellt mehrere Konstruktoren zur Verfügung. Für unsere Belange ist der geeignet,
                                                      dem wir den Namen des Mutex mitteilen können. Die Schwierigkeit besteht bei der Namensvergabe
                                                      darin, dass der Name systemeindeutig sein muss, um den Mutex identifizieren zu können.
                                                      Es bietet sich hier der Anwendungsname an, obwohl dieser auch keine Garantie für Eindeutigkeit
                                                      gibt. Möglicherweise müssen Sie hier noch Zusatzinformationen hinzufügen, um die Eindeutigkeit
                                                      zumindest mit hoher Wahrscheinlichkeit zu gewährleisten. Der entsprechende Konstruktor
                                                      erwartet darüber hinaus auch noch einen booleschen Wert, der angibt, ob dem aufrufenden
                                                      Thread der anfängliche Besitz des Mutex zugewiesen werden soll. Er ist <span class="clisting">true</span>, um dem aufrufenden Thread den anfänglichen Besitz des benannten Mutex zuzuweisen.
                                                      
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Über die Methode <span class="clisting">WaitOne</span><span class="clisting"><a class="indexterm" id="dodtpf2eb0c5e-804a-4178-be6f-2ee8feffed7c"></a><a class="indexterm" id="dodtp84be4942-4db0-4c4a-831c-b215b0aaa290"></a></span> kann eine Ressource das <span class="clisting">Mutex</span>-Objekt anfordern. Ist der Rückgabewert <span class="clisting">true</span>, ist das Objekt nicht im Besitz eines anderen Threads, sonst wäre der Rückgabewert
                                                      <span class="clisting">false.</span></p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard"><span class="clisting">WaitOne</span> werden zwei Argumente übergeben: Das erste beschreibt ein Zeitintervall, das angibt,
                                                      wie lange auf ein Signal gewartet werden soll. Über das zweite Argument können Sie
                                                      bei Anwendungen, die vor dem Warten auf den <span class="clisting">Mutex</span> den Zugriff auf Objekte oder Klassen über <span class="clisting">lock</span> sperren, festlegen, dass die Sperrung vor dem Warten aufgehoben und nach dem Warten
                                                      wieder gesetzt wird. Für uns hat dieser Parameter keine Bedeutung, wir setzen ihn
                                                      auf <span class="clisting">true</span>.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Im Beispielprogramm dient die Methode <span class="clisting">IsApplicationStarted</span> dazu, zu prüfen, ob das <span class="clisting">Mutex</span>-Objekt sich bereits im Besitz eines anderen Threads befindet. Je nachdem, wie das
                                                      Ergebnis der Prüfung ausfällt, wird eine entsprechende Konsolenausgabe erscheinen.
                                                   </p><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a id="dodtpa9584a73-4980-4804-b6ad-6e098f16b97c" name="dodtpa9584a73-4980-4804-b6ad-6e098f16b97c"></a><h3 class="t3"><span class="cfett">15.2.11    </span><span class="cfett"> Grundlagen asynchroner Methodenaufrufe</span><a xmlns="http://www.w3.org/1999/xhtml" class="indexterm" id="dodtpb9224a02-d424-40b0-a27e-89bbc57db71f"></a><a xmlns="http://www.w3.org/1999/xhtml" class="indexterm" id="dodtpc9d0eb49-efdd-42ce-ac27-53aaa02777a6"></a><a xmlns="http://www.w3.org/1999/xhtml" href="#dodtp6cd94ef0-9aae-45b1-9de3-f66b3125d6e4"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></img></a><a xmlns="http://www.w3.org/1999/xhtml" href="#dodtpd46936fd-3a82-40fa-b04d-10ceef675910"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></img></a></h3>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Wird aus einer Methode A heraus die Methode B aufgerufen, wird A erst dann mit den
                                                      Operationen fortfahren, wenn B vollständig abgearbeitet ist. Die Ausführung der beiden
                                                      Methoden erfolgt hintereinander, was als <span class="cfett">synchron</span> bezeichnet wird. Synchrone Operationen haben einen gravierenden Nachteil, denn solange
                                                      die Methode B ausgeführt wird, ist die Methode A blockiert. Um diese Problematik zu
                                                      vermeiden, sollten beide Methoden <span class="cfett">asynchron</span>, d. h. parallel nebeneinander operieren.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Asynchrone Bearbeitung setzt mindestens zwei Threads voraus. Sie haben auf den vergangenen
                                                      Seiten die wichtigsten Techniken kennengelernt, um mit Threads zu arbeiten. Sie wissen
                                                      nun, wie Sie Threads erzeugen und diese möglicherweise synchronisieren können, damit
                                                      Elemente nicht in einem ungültigen Zustand hinterlassen werden. Ihnen dürfte dabei
                                                      nicht entgangen sein, dass die Technik sehr komplex ist und einer genauen Planung
                                                      bedarf, um keine unbeabsichtigten und bösen Überraschungen zu erleben.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Auch in der .NET-Klassenbibliothek finden sich sehr viele Klassen, die Dienste anbieten,
                                                      deren Ausführung möglicherweise länger dauern kann. Die Dateioperationen zum Lesen
                                                      und Schreiben zählen dazu. Betrachten wir dazu exemplarisch die Klasse <span class="clisting">FileStream</span><span class="clisting"><a class="indexterm" id="dodtp481810b4-bfac-4e06-a58c-782b7a9a004f"></a></span>, die das Schreiben in eine Datei bzw. das Lesen aus einer Datei ermöglicht. (Anmerkung:
                                                      Wir werden uns den Klassen zur Ein- und Ausgabe in Kapitel 10 zuwenden.) Neben den
                                                      obligatorischen Methoden <span class="clisting">Read</span> und <span class="clisting">Write</span>, die beide synchron ausgeführt werden, werden von dieser Klasse aufgrund der weisen
                                                      Voraussicht des .NET-Entwicklerteams auch die asynchron operierenden Methoden <span class="clisting">BeginRead</span><span class="clisting"><a class="indexterm" id="dodtp2e614340-55d6-474d-918c-f667fd34a7aa"></a><a class="indexterm" id="dodtp02882763-5c4f-4097-a50d-4bb454c46fe3"></a></span> und <span class="clisting">BeginWrite</span><span class="clisting"><a class="indexterm" id="dodtpae9ee46a-798d-48b1-a9a0-950a47d0d398"></a><a class="indexterm" id="dodtpe44f3fd9-7142-4ace-99d8-2e16a949e38e"></a></span> veröffentlicht. Sehen wir uns kurz die Definition der erstgenannten Methode an, die
                                                      aus einem Datenstrom in ein <span class="clisting">byte</span>-Array einliest:
                                                   </p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="listing"><pre class="prettyprint">public override IAsyncResult BeginRead(byte[] array,<br xmlns="">                                       int offset,<br xmlns="">                                       int numBytes,<br xmlns="">                                       AsyncCallback userCallback,<br xmlns="">                                       object stateObject);<br></pre></div>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Der Rückgabewert des Methodenaufrufs ist ein Objekt, das die Schnittstelle <span class="clisting">IAsyncResult</span><span class="cfett"> </span>implementiert<span class="cfett"><a class="indexterm" id="dodtp0b983670-58d4-4fc0-9304-fe8216568931"></a></span>. Der Parameter vom Typ <span class="clisting">AsyncCallback</span><span class="clisting"><a class="indexterm" id="dodtpeeb81364-5420-4261-beae-b59aec2ef66e"></a><a class="indexterm" id="dodtpf9b395b2-19de-4348-8b79-cf683512aa37"></a></span> ist ein Delegate, der eine Methode im Client beschreibt, die nach der Beendigung
                                                      der Leseoperation aufgerufen wird.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Sowohl <span class="clisting">BeginRead</span> als auch <span class="clisting">BeginWrite</span> haben jeweils eine Partnermethode: <span class="clisting">EndRead</span><span class="clisting"><a class="indexterm" id="dodtp159da86d-a067-47b0-84d8-3b6e5a68b54f"></a><a class="indexterm" id="dodtp1da9cc83-94ab-459e-8b82-d86f73c75651"></a></span> und <span class="clisting">EndWrite</span><span class="cfett"><a class="indexterm" id="dodtp5f1dba22-9027-4fc6-b8d6-c5926f316a86"></a><a class="indexterm" id="dodtpbcaf8bfb-0f80-46e3-afb9-2483cacca314"></a></span>:
                                                   </p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="listing"><pre class="prettyprint">public override int EndRead<a class="indexterm" id="dodtp6a8600e3-de17-4b15-893b-87c90d64e115"></a>(IAsyncResult asyncResult);<br></br>public override void EndWrite<a class="indexterm" id="dodtp86ac0d0c-d01b-4e84-9506-5a9fd3c3c4b4"></a>(IAsyncResult asyncResult);<br></pre></div>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Auch diese Methoden erwarten eine Referenz vom Typ <span class="clisting">IAsyncResult</span><span class="clisting"><a class="indexterm" id="dodtp68f2a629-496f-45a2-ada1-0c0fd5f79e37"></a></span>. 
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Zwei Dinge fallen sofort auf:</p>
                                                   <ul xmlns="http://www.w3.org/1999/xhtml">
                                                      <li class="pgp">Die Methoden arbeiten gemäß Dokumentation asynchron, ohne dass im Aufrufer explizit
                                                         ein separater Thread gestartet werden muss. Diese Leistung wird von den Methoden intern
                                                         erbracht. 
                                                      </li>
                                                      <li class="pgp">Es treten zwei Typen auf, denen Sie hier zum ersten Mal begegnen und deren Bedeutung
                                                         noch unbekannt ist: <span class="clisting">IAsyncResult</span><span class="clisting"><a class="indexterm" id="dodtpbc5d0d6d-aa35-4143-9e4b-72c0720707cb"></a></span> und <span class="clisting">AsyncCallback</span><span class="clisting"><a class="indexterm" id="dodtp9b9d16ac-c5bc-443c-87b7-92faa550472c"></a></span>.
                                                      </li>
                                                   </ul>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Wir wollen uns nun mit der Codierung einer asynchronen Ausführung beschäftigen. Danach
                                                      wird auch die im ersten Moment sehr kompliziert erscheinende Parameterliste asynchron
                                                      arbeitender Methoden (wie <span class="clisting">BeginRead</span>) in einem anderen Licht erscheinen.
                                                   </p><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a id="dodtp6cd94ef0-9aae-45b1-9de3-f66b3125d6e4" name="dodtp6cd94ef0-9aae-45b1-9de3-f66b3125d6e4"></a><h3 class="t3"><span class="cfett">15.2.12    </span><span class="cfett"> Asynchroner Methodenaufruf</span><a xmlns="http://www.w3.org/1999/xhtml" class="indexterm" id="dodtp30a215c0-2bcd-42c6-83ec-d66b8612d510"></a><a xmlns="http://www.w3.org/1999/xhtml" href="#dodtp9bd6facd-ddf6-4ead-b467-4f0cdde0ab10"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></img></a><a xmlns="http://www.w3.org/1999/xhtml" href="#dodtpa9584a73-4980-4804-b6ad-6e098f16b97c"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></img></a></h3>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Der C#-Compiler stellt mit <span class="clisting">BeginInvoke</span><span class="clisting"><a class="indexterm" id="dodtpb12d927b-0cf5-4784-9a59-fa76e16b08b7"></a><a class="indexterm" id="dodtp173b7e91-5008-4ddd-94c8-c17ec1ffcf61"></a></span> und <span class="clisting">EndInvoke</span><span class="clisting"><a class="indexterm" id="dodtpa43e2c02-836a-4531-bcd5-307514d8f338"></a><a class="indexterm" id="dodtp20d053f8-f0bc-41ae-8a02-9fb15c6e74d1"></a></span> jedem Delegate zwei Methoden zur Verfügung, die im Rahmen einer asynchronen Operation
                                                      von entscheidender Bedeutung sind.
                                                   </p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="kasten">
                                                      <p class="pbstandard">Beachten Sie bitte, dass es sich bei <span class="clisting">BeginInvoke</span> und <span class="clisting">EndInvoke</span><span class="clisting"><a class="indexterm" id="dodtpd605dc84-f445-487b-923a-c08df35d5c77"></a></span> um sprachspezifische Methoden handelt, die nicht in der Klasse <span class="clisting">Delegate</span><span class="cfett"> </span>definiert sind, aber dennoch von jedem .NET-Compiler veröffentlicht werden sollten
                                                         &#8211; möglicherweise auch unter einem anderen Namen. 
                                                      </p>
                                                   </div>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Die Methode <span class="clisting">BeginInvoke</span><span class="clisting"><a class="indexterm" id="dodtp1fda917b-7856-4ea9-a76e-c4614714b988"></a></span> ist sehr mächtig, denn wenn Sie sie auf der Referenz eines Delegates aufrufen, wird
                                                      ein Hintergrundthread erzeugt, in dem die vom Delegate beschriebene Methode ausgeführt
                                                      wird. Der aufrufende Thread macht mit seiner eigenen Arbeit weiter, anstatt auf die
                                                      Beendigung der aufgerufenen Methode zu warten.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Dazu ein kleines Beispiel. Nehmen wir an, dass die Methode <span class="clisting">DoSomething</span>, die eine längere Zeit zur Ausführung benötigt, aufgerufen werden soll. <span class="clisting">DoSomething</span> sei wie folgt definiert:
                                                   </p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="listing"><pre class="prettyprint"><span class="clistingfett">public void DoSomething()</span> {<br xmlns="">  for(int i = 0; i &lt;= 30; i++) {<br xmlns="">    Console.Write(".X.");<br xmlns="">    Thread.Sleep(10);<br xmlns="">  }<br xmlns="">}<br></pre></div>
                                                   <p class="plistingunter"><span xmlns="http://www.w3.org/1999/xhtml" class="nummerierung">Listing 15.13  </span>Eine Methode, die längere Zeit für die Ausführung benötigt
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Ein Client, der diese Methode asynchron ausführen möchte, kann einen Delegate deklarieren
                                                      und diesem die Adresse der Methode <span class="ckursiv">DoSomething</span> übergeben:
                                                   </p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="listing"><pre class="prettyprint">public delegate void MyDelegate();<br xmlns="">[...]<br xmlns="">MyDelegate del = new MyDelegate(obj.DoSomething);<br xmlns="">del.BeginInvoke(...);<br></pre></div>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Das reicht bereits aus, um <span class="clisting">DoSomething</span> in einem separaten Thread abzuarbeiten.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Dem Aufruf von <span class="clisting">BeginInvoke</span> müssen Argumente übergeben werden, die unsere Anweisung noch nicht enthält. Sehen
                                                      wir uns deshalb nun die Definition von <span class="clisting">BeginInvoke</span> an. 
                                                   </p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="listing"><pre class="prettyprint">public IAsyncResult BeginInvoke([Parameterliste,] <br></br>                                AsyncCallback, Object); <br></pre></div>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Aufgerufen wird <span class="clisting">BeginInvoke</span> auf die Instanz eines Delegates, der auf eine bestimmte Methode zeigt. Weist die
                                                      aufzurufende Methode eine Parameterliste auf, müssen die erforderlichen Argumente
                                                      von <span class="clisting">BeginInvoke</span> an die Methode weitergeleitet werden. Dazu dient die optionale Parameterliste. 
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Theoretisch wäre das bereits vollkommen ausreichend, um die aufgerufene Methode asynchron
                                                      auszuführen. In der Regel benötigt der aufrufende Code aber Kenntnis von der Beendigung
                                                      der asynchronen Ausführung, beispielsweise wenn er die Rückgabewerte verarbeitet.
                                                      Folglich muss es eine Möglichkeit geben, die es der asynchron aufgerufenen Methode
                                                      ermöglicht, den Aufrufer davon zu unterrichten, dass sie ihre Operationen beendet
                                                      hat. Dabei kann es sich nur um den Aufruf einer Methode im Initiator der asynchronen
                                                      Operation handeln.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Konsequenterweise muss der asynchron aufgerufenen Methode die Adresse der Rückrufmethode
                                                      im Aufrufer bekannt sein. Das klingt wieder verdächtig nach einem Delegate &#8211; und tatsächlich
                                                      ist dem so, denn dem Aufruf von <span class="clisting">BeginInvoke</span> werden nicht nur die Argumente übergeben, die die asynchron aufgerufene Methode benötigt,
                                                      sondern darüber hinaus auch ein Objekt vom Typ <span class="clisting">AsyncCallback</span>, bei dem es sich um den erforderlichen Delegate handelt.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Die Definition des Delegates <span class="clisting">AsyncCallback</span> lautet:
                                                   </p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="listing"><pre class="prettyprint"><span class="clistingfett">public delegate void AsyncCallback</span><a class="indexterm" id="dodtpa43e5426-9ca4-4020-afac-df2392059e2e"></a><a class="indexterm" id="dodtpfcea2ccf-67c1-4e1e-9e22-997135ee51da"></a>(IAsyncResult ar);<br></pre></div>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Die Methode, die aus der asynchron ausgeführten Methode zurückgerufen wird, muss den
                                                      Rückgabetyp <span class="clisting">void</span> aufweisen und einen Parameter vom Typ <span class="clisting">IAsyncResult</span> definieren. <span class="clisting">BeginInvoke</span> verfügt noch über einen weiteren Parameter vom Typ <span class="clisting">object</span>. Hier kann beim Start der asynchronen Operation ein beliebiges Objekt übergeben werden,
                                                      das Informationen beliebiger Art enthält.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Das hört sich komplizierter an, als es tatsächlich ist. Daher wollen wir den Ablauf
                                                      schrittweise an einem kleinen Beispiel verfolgen. Gegeben seien dazu die beiden Klassen
                                                      <span class="clisting">Program</span> und <span class="clisting">Demo</span> wie folgt:
                                                   </p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="listing"><pre class="prettyprint"><span class="clistingfett">class Program</span> {<br xmlns="">  <span class="clistingfett">static void Main(string[] args)</span> {<br xmlns="">    [...]<br xmlns="">  }<br xmlns="">}<br></br><span class="clistingfett">class Demo</span> {<br xmlns="">  <span class="clistingfett">public void DoSomething()</span> {<br xmlns="">    [...]<br xmlns="">  }<br xmlns="">}<br></pre></div>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Aus <span class="clisting">Main</span> heraus soll die Methode <span class="clisting">DoSomething</span> in der Klasse <span class="clisting">Demo</span> asynchron aufgerufen werden. Diese Forderung bewirkt, dass wir <span class="clisting">BeginInvoke</span> auf einem Delegate aufrufen müssen, der die asynchron auszuführende Methode im Objekt
                                                      vom Typ <span class="clisting">Demo</span> beschreibt. Dazu wird zunächst ein Delegate mit
                                                   </p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="listing"><pre class="prettyprint">public delegate void MyDelegate();<br></pre></div>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">deklariert. Anschließend verschaffen wir uns ein Objekt vom Typ des Delegates, dem
                                                      als Argument die asynchron auszuführende Methode übergeben wird. 
                                                   </p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="listing"><pre class="prettyprint">private MyDelegate del;<br xmlns="">[...]<br xmlns="">del = new MyDelegate(obj.DoSomething);<br></pre></div>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Mit</p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="listing"><pre class="prettyprint">del.BeginInvoke(...);<br></pre></div>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">wird die asynchrone Ausführung von <span class="clisting">DoSomething</span> in einem Hintergrundthread gestartet. Allerdings ist die Anweisung noch unvollständig
                                                      &#8211; symbolisiert durch die Punkte. Wir sollten in <span class="clisting">Program</span> nämlich noch eine Methode bereitstellen, mit der der Hintergrundthread das Objekt
                                                      vom Typ <span class="clisting">Program</span> über das Ende seiner Operation benachrichtigt. Die Definition der Rückrufmethode
                                                      muss der Vorgabe des Delegates <span class="clisting">AsyncCallback</span> entsprechen, demnach also einen Parameter vom Typ <span class="clisting">IAsyncResult</span> enthalten. Wir nennen diese Methode <span class="clisting">CallbackMethod</span>.
                                                   </p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="listing"><pre class="prettyprint"><span class="clistingfett">class Program </span>{<br xmlns="">  [...]<br xmlns="">  <span class="clistingfett">static void Main(string[] args)</span> {...}<br></br>  <span class="clistingfett">public static void CallbackMethod(IAsyncResult ar)</span> {<br xmlns="">    [...]<br xmlns="">  }<br xmlns="">}<br></pre></div>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Das Objekt vom Typ <span class="clisting">IAsyncResult</span> entspricht dem Rückgabewert von <span class="clisting">BeginInvoke</span>. Es veröffentlicht insgesamt sechs Eigenschaften. Dazu gehört unter anderem auch
                                                      <span class="clisting">IsCompleted</span><span class="clisting"><a class="indexterm" id="dodtp5f0793ad-0402-4267-9e20-300ddcf4745d"></a></span>. Über <span class="clisting">IsCompleted</span><span class="clisting"><a class="indexterm" id="dodtp1228f4b7-50cd-4b9e-8eaf-4734fef9264f"></a></span> kann der Aufrufer jederzeit feststellen, ob die asynchrone Ausführung bereits beendet
                                                      ist. Eine zweite, sehr interessante Eigenschaft ist <span class="clisting">AsyncState</span><span class="clisting"><a class="indexterm" id="dodtpeafc4c42-894c-48a3-b8b1-6b73c9ec505a"></a><a class="indexterm" id="dodtp17ac50d2-b8b6-4645-bf21-3e73da2ba9ee"></a></span>, die genau das Objekt abruft, das als letzter Parameter dem Aufruf von <span class="clisting">BeginInvoke</span> übergeben worden ist. Sie werden später in einem anderen Beispiel die sinnvolle Auswertung
                                                      dieses Objekts sehen. 
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Wir wollen nun unser Beispiel komplettieren und Code einsetzen, der tatsächlich einige
                                                      Zeit in Anspruch nimmt, damit wir den Effekt des asynchronen Aufrufs beobachten können.
                                                   </p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="listing"><pre class="prettyprint"><span class="clistingfett">// Beispiel: ..\Kapitel 15\AsynchronerAufruf_1</span><br></br>public delegate void MyDelegate();<br></br><span class="clistingfett">class Program </span>{<br xmlns="">  private static MyDelegate del;<br></br><span class="clistingfett">  static void Main(string[] args) </span>{<br xmlns="">    Demo obj = new Demo();<br xmlns="">    del = new MyDelegate(obj.DoSomething);<br xmlns="">    AsyncCallback callback = new AsyncCallback(CallbackMethod);<br></br>    // die Methode AsyncTest in Demo asynchron aufrufen<br></br>    del.BeginInvoke(callback, null);<br></br>    // zeitaufwendige Ausführung<br></br>    for(int i = 0; i &lt;= 100; i++) {<br xmlns="">      Console.Write(".");<br xmlns="">      Thread.Sleep(10);<br xmlns="">    }<br xmlns="">    Console.ReadLine();<br xmlns="">  }<br></br>  // die zurückgerufene Methode<br></br><span class="clistingfett">  public static void CallbackMethod(IAsyncResult ar) </span>{<br xmlns="">    Console.Write("Ich habe fertig.");<br xmlns="">  }<br xmlns="">}<br></br><span class="clistingfett">class Demo </span>{<br></br>  // asynchron aufzurufende Methode<br></br>  <span class="clistingfett">public void DoSomething() </span>{<br></br>    // zeitintensive Ausführung<br></br>    for(int i = 0; i &lt;= 30; i++) {<br xmlns="">      Console.Write("X");<br xmlns="">      Thread.Sleep(10);<br xmlns="">    }<br xmlns="">  }<br xmlns="">}<br></pre></div>
                                                   <p class="plistingunter"><span xmlns="http://www.w3.org/1999/xhtml" class="nummerierung">Listing 15.14  </span>Asynchroner Methodenaufruf
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">In Abbildung 15.6 ist das Ergebnis des Aufrufs zu sehen. Es ist eindeutig zu erkennen,
                                                      dass die Punkte und »X«-Zeichen mehr oder weniger abwechselnd ausgegeben werden, denn
                                                      beide Methoden arbeiten parallel. Beendet wird die asynchrone Operation durch den
                                                      Rückruf von <span class="clisting">CallbackMethod</span>, was durch die Ausgabe des bekannten Satzes »Ich habe fertig« bestätigt wird. 
                                                   </p>
                                                   <p><a href="bilder/15_06.png" rel="lightbox" title="Ausgabe eines asynchronen Aufrufs"><img class="bild" border="1" src="bilderklein/klein15_06.png" alt="Abbildung"></a></p>
                                                   <p class="pbildunter"><span xmlns="http://www.w3.org/1999/xhtml" class="nummerierung">Abbildung 15.6  </span>Ausgabe eines asynchronen Aufrufs
                                                   </p><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a id="dodtp9bd6facd-ddf6-4ead-b467-4f0cdde0ab10" name="dodtp9bd6facd-ddf6-4ead-b467-4f0cdde0ab10"></a><h3 class="t3"><span class="cfett">15.2.13    </span><span class="cfett"> Asynchroner Aufruf mit Rückgabewerten</span><a xmlns="http://www.w3.org/1999/xhtml" href="#dodtpced1bada-5ac1-498c-9821-5c3fe6e65f9f"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></img></a><a xmlns="http://www.w3.org/1999/xhtml" href="#dodtp6cd94ef0-9aae-45b1-9de3-f66b3125d6e4"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></img></a></h3>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Möglicherweise liefert die asynchrone Methode als Resultat ihrer Operation einen Rückgabewert.
                                                      Vielleicht werden auch über die Parameterliste Ergebnisse bereitgestellt. Wird aus
                                                      dem Hintergrundthread heraus die Rückrufmethode des Initiators der asynchronen Operation
                                                      aufgerufen, stehen die Ergebnisse jedoch nicht automatisch zur Verfügung. Sie müssen
                                                      ausdrücklich abgerufen werden. Dazu dient die Methode <span class="clisting">EndInvoke</span> des Delegates.
                                                   </p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="listing"><pre class="prettyprint">public Datentyp EndInvoke<a class="indexterm" id="dodtpcf7a75f0-e00a-4ce8-9837-624de68dd14c"></a><a class="indexterm" id="dodtpb618848a-d6cd-4694-ac64-5c3d2eb25482"></a>([Parameterliste,] IAsyncResult);<br></pre></div>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Wie bei <span class="clisting">BeginInvoke</span> müssen Sie auch an <span class="clisting">EndInvoke</span> eine vorgeschriebene Parameterliste übergeben, die nicht identisch mit der Parameterliste
                                                      von <span class="clisting">BeginInvoke</span> ist: Sie darf nur die Referenzparameter der asynchronen Methode enthalten, damit
                                                      <span class="clisting">EndInvoke</span> die Resultate dort hineinschreiben kann. Die Angabe der Werteparameter ist nicht
                                                      erlaubt. Der einzige grundsätzlich immer zwingend erforderliche Parameter ist vom
                                                      Typ <span class="clisting">IAsyncResult</span><span class="clisting"><a class="indexterm" id="dodtpd168572d-f3f9-4700-b86c-33b03da38610"></a></span>. Hier wird das Objekt übergeben, das beim Aufruf von <span class="clisting">BeginInvoke</span> dem letzten Parameter übergeben worden ist.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Wir wollen nun das Beispiel <span class="ckursiv">AsynchronerAufruf_1</span> ändern, um zu sehen, wie eine asynchrone Methode behandelt wird, die sowohl Werte-
                                                      als auch Referenzparameter erwartet und darüber hinaus auch noch einen Rückgabewert
                                                      hat. Dazu implementieren wir die Methode <span class="clisting">DoSomething</span> wie folgt:
                                                   </p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="listing"><pre class="prettyprint"><span class="clistingfett">public string DoSomething(int x, ref long y) </span>{<br></br>  // zeitaufwendige Ausführung<br></br>  for(int i = 0; i &lt;= 30; i++) {<br xmlns="">    Console.Write("X");<br xmlns="">    Thread.Sleep(10);<br xmlns="">  }<br xmlns="">  y = 12345;<br xmlns="">  return "Ich habe fertig.";<br xmlns="">}<br></pre></div>
                                                   <p class="plistingunter"><span xmlns="http://www.w3.org/1999/xhtml" class="nummerierung">Listing 15.15  </span>Methode mit Rückgabewert
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Die Parameterliste enthält jetzt den Referenzparameter <span class="ckursiv">y</span> und den Werteparameter <span class="ckursiv">x</span>, außerdem liefert die Methode eine Zeichenfolge zurück.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Die Änderung der Signatur hat natürlich auch im auslösenden Thread Konsequenzen. Der
                                                      Delegate, der den Aufruf der Methode kapselt, muss an die veränderten Bedingungen
                                                      angepasst werden:
                                                   </p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="listing"><pre class="prettyprint">public delegate string MyDelegate(int x, ref long y);<br></pre></div>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Gleiches gilt auch für den Start der asynchronen Bearbeitung, denn nun reicht es nicht
                                                      mehr aus, mit <span class="clisting">BeginInvoke</span> einfach nur einen Delegate auf die Rückrufmethode zu übergeben sowie die Referenz
                                                      auf ein Objekt, in das der asynchrone Aufruf Informationen schreiben könnte. Wir müssen
                                                      stattdessen auch die Parameter der asynchronen Methode in der richtigen Reihenfolge
                                                      bedienen:
                                                   </p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="listing"><pre class="prettyprint">del.BeginInvoke(intVar, ref lngVar, callback, null);<br></pre></div>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard"><span class="clisting">DoSomething</span> nimmt nun eine Kopie des <span class="clisting">int</span>-Wertes und die Adresse des <span class="clisting">long</span>-Wertes entgegen, kann mit diesen die erforderlichen Operationen ausführen und zum
                                                      Abschluss durch Aufruf der über <span class="ckursiv">callback</span> bekannt gegebenen Adresse die Methode <span class="clisting">CallbackMethod</span> informieren.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Der Implementierung der Rückrufmethode kommt nun eine entscheidende Bedeutung zu.
                                                      Es gilt, sowohl den Rückgabewert als auch den in diesem Fall geänderten Inhalt der
                                                      Variablen <span class="ckursiv">lngVar</span> auszuwerten. Dem Aufruf von <span class="clisting">EndInvoke</span> übergeben wir die Adresse von <span class="ckursiv">lngVar</span> und holen uns den Rückgabewert an der Konsole ab:
                                                   </p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="listing"><pre class="prettyprint"><span class="clistingfett">public static void CallbackMethod(IAsyncResult ar) </span>{<br xmlns="">  Console.Write(del.EndInvoke(ref lngVar, ar));<br xmlns="">  Console.Write("..Wert y = {0}", lngVar);<br xmlns="">}<br></pre></div>
                                                   <p class="plistingunter"><span xmlns="http://www.w3.org/1999/xhtml" class="nummerierung">Listing 15.16  </span>Implementierung der Rückrufmethode
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Die Konsolenausgabe bestätigt, dass unser Unterfangen von Erfolg beschieden ist: Wir
                                                      erhalten sowohl die Zeichenfolge als auch den veränderten Inhalt des Feldes <span class="ckursiv">intVar</span>.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Zum Abschluss fassen wir das Beispielprogramm noch einmal zusammen.</p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="listing"><pre class="prettyprint"><span class="clistingfett">// Beispiel: ..\ Kapitel 15\AsynchronerAufruf_2</span><br></br>public delegate string MyDelegate(int x, ref long y);<br></br><span class="clistingfett">class Program </span>{<br xmlns="">  private static MyDelegate del;<br xmlns="">  private static int intVar = 4711;<br xmlns="">  private static long lngVar;<br></br><span class="clistingfett">  static void Main(string[] args) </span>{<br xmlns="">    Demo obj = new Demo();<br xmlns="">    del = new MyDelegate(obj.DoSomething);<br xmlns="">    AsyncCallback callback = new AsyncCallback(CallbackMethod);<br></br>    // die Methode AsyncTest in Demo asynchron aufrufen<br></br>    del.BeginInvoke(intVar, ref lngVar, callback, null);<br></br>    // zeitaufwendige Ausführung<br></br>    for(int i = 0; i &lt;= 100; i++) {<br xmlns="">      Console.Write(".P.");<br xmlns="">      Thread.Sleep(10);<br xmlns="">    }<br xmlns="">    Console.ReadLine();<br xmlns="">  }<br></br><span class="clistingfett">  public static void CallbackMethod(IAsyncResult ar) </span>{<br xmlns="">    Console.Write(del.EndInvoke(ref lngVar, ar));<br xmlns="">    Console.Write("..Wert y = {0}", lngVar);<br xmlns="">  }<br xmlns="">}<br></br><span class="clistingfett">class Demo </span>{<br xmlns="">  <span class="clistingfett">public string DoSomething(int x, ref long y) </span>{<br></br>    // zeitaufwendige Ausführung<br></br>    for(int i = 0; i &lt;= 30; i++) {<br xmlns="">      Console.Write(".X.");<br xmlns="">      Thread.Sleep(10);<br xmlns="">    }<br xmlns="">    y = 12345;<br xmlns="">    return "Ich habe fertig.";<br xmlns="">  }<br xmlns="">}<br></pre></div>
                                                   <p class="plistingunter"><span xmlns="http://www.w3.org/1999/xhtml" class="nummerierung">Listing 15.17  </span>Asynchroner Methodenaufruf mit Rückgabewert
                                                   </p>
                                                   <p><a href="bilder/15_07.png" rel="lightbox" title="Ausgabe des Beispiels »AsynchronerAufruf_2«"><img class="bild" border="1" src="bilderklein/klein15_07.png" alt="Abbildung"></a></p>
                                                   <p class="pbildunter"><span xmlns="http://www.w3.org/1999/xhtml" class="nummerierung">Abbildung 15.7  </span>Ausgabe des Beispiels »AsynchronerAufruf_2«
                                                   </p><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a id="dodtpced1bada-5ac1-498c-9821-5c3fe6e65f9f" name="dodtpced1bada-5ac1-498c-9821-5c3fe6e65f9f"></a><h3 class="t3"><span class="cfett">15.2.14    </span><span class="cfett"> Eine Klasse mit asynchronen Methodenaufrufen</span><a xmlns="http://www.w3.org/1999/xhtml" href="#dodtp9bd6facd-ddf6-4ead-b467-4f0cdde0ab10"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></img></a></h3>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Am Anfang dieses Abschnitts wurde schon darauf hingewiesen, dass einige Klassen der
                                                      .NET-Klassenbibliothek Methoden mit asynchroner Verarbeitung anbieten. Die Klasse
                                                      <span class="clisting">FileStream</span><span class="clisting"><a class="indexterm" id="dodtpe15befd8-143c-483c-9e22-680677be8567"></a></span> im Namespace <span class="clisting">System.IO</span> ist ein Beispiel dafür. Es werden allerdings nicht die Methoden <span class="clisting">BeginInvoke</span> und <span class="clisting">EndInvoke</span> aufgerufen, sondern zwei ähnlich lautende: <span class="clisting">BeginRead</span><span class="clisting"><a class="indexterm" id="dodtp5a13c4a7-3851-4c18-bc43-f7def0d125e0"></a></span> und <span class="clisting">EndRead</span><span class="clisting"><a class="indexterm" id="dodtped768691-89b7-484c-8519-080f4965ec85"></a></span> bzw. <span class="clisting">BeginWrite</span><span class="clisting"><a class="indexterm" id="dodtp1ae91e15-acff-4f9b-9ebd-98385bdcfc7f"></a></span> und <span class="clisting">EndWrite</span><span class="clisting"><a class="indexterm" id="dodtpe90953e6-e5d4-4c64-a0de-2af56cc91ec9"></a></span>.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Wir wollen uns nun ansehen, wie eine Klasse aufgebaut ist, die ähnlich wie <span class="clisting">FileStream</span> implementiert ist. Dabei lernen wir einerseits, wie wir die asynchronen Methoden
                                                      der Klassen des .NET Frameworks behandeln müssen, andererseits aber auch, diese Technik
                                                      in eigenen Klassen zu nutzen.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Am Anfang steht die Idee, eine Methode zu entwickeln, von der wir annehmen, dass sie
                                                      in Abhängigkeit von den Umgebungsbedingungen und der Art der Operation eine längere
                                                      Zeit zur Bearbeitung in Anspruch nehmen kann. Wir wollen diese Methode nachfolgend
                                                      <span class="clisting">Calculate</span> nennen, die Klasse dazu <span class="clisting">Mathematics</span>. 
                                                   </p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="listing"><pre class="prettyprint"><span class="clistingfett">class Mathematics </span>{<span class="clistingfett"><br xmlns="">  public int Calculate(int x) </span>{<br xmlns="">    Console.Write("---Bearbeitung startet---"); <br xmlns="">    for (int i = 0; i &lt;= 20; i++) {<br xmlns="">      Console.Write(".X.");<br xmlns="">      Thread.Sleep(10);<br xmlns="">    }<br xmlns="">    Console.Write("---Bearbeitung beendet---");<br xmlns="">    return x * x;<br xmlns=""> }<br xmlns="">}<br></pre></div>
                                                   <p class="plistingunter"><span xmlns="http://www.w3.org/1999/xhtml" class="nummerierung">Listing 15.18  </span>Klasse mit einer zeitaufwendigen Methode
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Die <span class="clisting">for</span>-Schleife simuliert eine länger andauernde Operation. Diese Implementierung arbeitet
                                                      synchron. Da wir uns bewusst sind, dass <span class="ckursiv">Calculate</span> vielleicht auch eine Stunde zur vollständigen Ausführung brauchen könnte (wir sind
                                                      mit unserer Annahme sehr großzügig), bieten wir zusätzlich eine asynchrone Variante
                                                      an. Dazu benötigen wir zwei weitere Methoden, die einer allgemeinen Konvention folgend
                                                      als <span class="clisting">BeginXxx</span> und <span class="clisting">EndXxx</span> bezeichnet werden &#8211; in unserer Klasse demnach <span class="clisting">BeginCalculate</span> und <span class="clisting">EndCalculate</span><span class="ckursiv">.</span> Die noch unvollständige Klassenstruktur sieht dann folgendermaßen aus:
                                                   </p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="listing"><pre class="prettyprint"><span class="clistingfett">class Mathematics </span>{<br></br>  // Methode Calculate wird synchron ausgeführt<br></br><span class="clistingfett">  public int Calculate(int x) </span>{<br xmlns="">    ...<br xmlns="">  }<br></br>  // Start der asynchronen Ausführung<br></br><span class="clistingfett">  public ... BeginCalculate(...) </span>{<br xmlns="">    ...<br xmlns="">  }<br></br>  // Beenden der asynchronen Ausführung<br></br><span class="clistingfett">  public ... EndCalculate(...) </span>{<br xmlns="">    ...<br xmlns="">  }<br xmlns="">}<br></pre></div>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">An dieser Stelle kommt es zu der wichtigsten Entscheidung überhaupt. Was wir beabsichtigen,
                                                      ist die asynchrone Ausführung der Methode <span class="clisting">Calculate</span>. Asynchronität heißt aber auch, dass ein weiterer Thread gestartet werden muss, sobald
                                                      die Methode <span class="clisting">BeginCalculate</span> aufgerufen wird. Wenn wir in dieser Methode ein Objekt vom Typ <span class="clisting">Thread</span> erzeugen und seinem Konstruktor einen Delegate übergeben, bräuchten wir auch noch
                                                      ein Objekt, das das Interface <span class="clisting">IAsyncResult</span> implementiert, müssten zwangsläufig dessen Methoden implementieren usw. 
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Die Entwicklung auf diese Weise zu gestalten, ist sehr aufwendig. Es gibt eine viel
                                                      einfachere Lösung, da die beiden Methoden <span class="clisting">BeginInvoke</span><span class="clisting"><a class="indexterm" id="dodtp946bdb0c-ae81-419c-8c40-7a5c489db544"></a></span> und <span class="clisting">EndInvoke</span><span class="clisting"><a class="indexterm" id="dodtpf8dd06a1-98a2-41d8-9f31-9a6f6ac42f8c"></a></span> genau das leisten, was wir brauchen. Also benutzen wir sie auch, um das Ziel effizient
                                                      zu erreichen. Dazu wird die Logik, die in den Abschnitten 15.5.2 und 15.5.3 beschrieben
                                                      wurde, innerhalb der Klasse <span class="clisting">Mathematics</span> implementiert. 
                                                   </p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="listing"><pre class="prettyprint"><span class="clistingfett">// Beispiel: ..\ Kapitel 15\AsynchronerAufruf_3</span><br></br><span class="clistingfett">class Mathematics </span>{<br xmlns="">  private delegate int CalculateHandler(int x);<br xmlns="">  CalculateHandler del;<br></br>  // Methode Calculate wird synchron ausgeführt<br></br>  <span class="clistingfett">public int Calculate(int x) </span>{<br xmlns="">    Console.Write("---Bearbeitung startet---"); <br xmlns="">    for (int i = 0; i &lt;= 20; i++) {<br xmlns="">      Console.Write("X");<br xmlns="">      Thread.Sleep(10);<br xmlns="">    }<br xmlns="">    Console.Write("---Bearbeitung beendet---");<br xmlns="">    return x * x;<br xmlns="">  }<br></br>  // Start der asynchronen Ausführung<br></br>  <span class="clistingfett">public IAsyncResult BeginCalculate(int intVar,<br xmlns="">            AsyncCallback callback, object state) </span>{<br xmlns="">    del = new CalculateHandler(Calculate);<br></br>    // Aufruf der Methode Calculate, die in einem eigenen <br></br>    // Thread ausgeführt wird<br></br>    return del.BeginInvoke(intVar, callback, state);<br xmlns="">  }<br></br>  // Beenden der asynchronen Ausführung<br></br>  <span class="clistingfett">public int EndCalculate(IAsyncResult ar) </span>{<br xmlns="">    return del.EndInvoke(ar);<br xmlns="">  }<br xmlns="">}<br></pre></div>
                                                   <p class="plistingunter"><span xmlns="http://www.w3.org/1999/xhtml" class="nummerierung">Listing 15.19  </span>Klasse mit Methode für den synchronen und asynchronen Aufruf
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Dem Aufruf der Methode <span class="clisting">BeginCalculate</span> werden die Daten übergeben, die die Methode <span class="clisting">Calculate</span> für ihre Operation benötigt. In unserem Beispiel handelt es sich nur um einen als
                                                      Werteparameter deklarierten Integer. Der zweite Parameter erhält die Referenz auf
                                                      einen Delegate, der die Rückrufmethode im Aufrufer beschreibt. Der dritte und letzte
                                                      Parameter dient dazu, ein Objekt bereitzustellen, mit dem Daten zwischen dem aufrufenden
                                                      und dem aufgerufenen Objekt ausgetauscht werden. Ein solches Objekt ist in unserem
                                                      Beispielcode nicht vorgesehen. 
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Der Aufruf von <span class="clisting">BeginCalculate</span> orientiert sich an dem von <span class="clisting">BeginInvoke</span><span class="cfett"> </span>&#8211; und das ist typisch für Klassen im .NET Framework, die asynchrone Methoden offenlegen.
                                                      Unter ähnlicher Prämisse wird auch <span class="clisting">EndCalculate</span> implementiert; der Rückgabewert des internen <span class="clisting">EndInvoke</span>-Aufrufs wird zum Rückgabewert der Instanzmethode.
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Zum Schluss müssen wir noch testen, ob die Klassenimplementierung auch unseren Anforderungen
                                                      genügt. 
                                                   </p>
                                                   <div xmlns="http://www.w3.org/1999/xhtml" class="listing"><pre class="prettyprint">class Program <br xmlns="">{<br xmlns="">  <span class="clistingfett">static void Main(string[] args)</span> <br xmlns="">  { <br xmlns="">    Mathematics math = new Mathematics();<br xmlns="">    int value = 23;<br xmlns="">    AsyncCallback callback = new AsyncCallback(CallbackMethod);<br></br>    // Aufruf der asynchronen Ausführung<br></br>    math.BeginCalculate(value, callback, math);<br xmlns="">    for (int i = 0; i &lt;= 100; i++) {<br xmlns="">      Console.Write(".{0}.", i);<br xmlns="">      Thread.Sleep(5);<br xmlns="">    }<br xmlns="">    Console.ReadLine();<br xmlns="">  }<br></br>  // diese Methode wird vom Server aufgerufen<br></br>  <span class="clistingfett">public static void CallbackMethod(IAsyncResult ar)</span> <br xmlns="">  {<br xmlns="">    Mathematics math = (Mathematics)ar.AsyncState;<br></br>    // das Ergebnis der asynchronen Operation abholen<br></br>    int result = math.EndCalculate(ar);<br xmlns="">    Console.Write("---Resultat = {0} ", result);<br xmlns="">    Console.Write("---FERTIG---");<br xmlns="">  }<br xmlns="">}<br></pre></div>
                                                   <p class="plistingunter"><span xmlns="http://www.w3.org/1999/xhtml" class="nummerierung">Listing 15.20  </span>Testen des asynchronen Methodenaufrufs
                                                   </p>
                                                   <p xmlns="http://www.w3.org/1999/xhtml" class="pstandard">Beachten Sie bitte die Variable <span class="ckursiv">math</span> vom Typ <span class="clisting">Mathematics</span>. Sie ist als lokale Variable in der Methode <span class="clisting">Main</span> definiert und daher auch außerhalb der Methode nicht sichtbar. Um dennoch die <span class="clisting">EndCalculate</span>-Methode dieses Objekts aufrufen zu können, wird die Referenz an den letzten Parameter
                                                      von <span class="clisting">BeginCalculate</span> übergeben. In <span class="clisting">BeginCalculate</span> wird das Objekt an <span class="clisting">BeginInvoke</span> weitergeleitet. Die Folge ist, dass wir in unserer Callback-Methode nur die Eigenschaft
                                                      <span class="clisting">AsyncState</span> auswerten müssen, denn hier kommt das <span class="clisting">Mathematics</span>-Objekt genau dort an, wo wir dessen <span class="clisting">EndCalculate</span>-Methode aufrufen müssen, um das Resultat der Operation abzufragen. Die Ausgabe an
                                                      der Konsole wird so aussehen wie in Abbildung 15.8.
                                                   </p>
                                                   <p><a href="bilder/15_08.png" rel="lightbox" title="Ausgabe des Beispiels »AsynchronerAufruf_3«"><img class="bild" border="1" src="bilderklein/klein15_08.png" alt="Abbildung"></a></p>
                                                   <p class="pbildunter"><span xmlns="http://www.w3.org/1999/xhtml" class="nummerierung">Abbildung 15.8  </span>Ausgabe des Beispiels »AsynchronerAufruf_3«
                                                   </p><br><hr><a name="kommentar"></a><h3>Ihr Kommentar</h3>
                                                   <p>Wie hat Ihnen das &lt;openbook&gt; gefallen? Wir freuen uns immer über Ihre freundlichen
                                                      und kritischen Rückmeldungen.
                                                   </p>
                                                   <!--<form action="http://www.galileo-press.de/feedback/openbook" method="post" style="text-align: center; margin-top: 10px;"><input type="hidden" name="openbookurl" value="https://www.galileo-press.de/openbook/?GPP=opvcs15_002.html"><input type="hidden" name="buchtitel" value="Visual C# 2012"><input type="hidden" name="Kapitel" value="15  Multithreading und die Task Parallel Library (TPL)"><table border="0">
                                                         <tbody>
                                                            <tr>
                                                               <td><label for="name">Name</label><br></td>
                                                               <td><input type="text" name="name" id="name" size="40"><br></td>
                                                            </tr>
                                                            <tr>
                                                               <td><label for="email">E-Mail</label><br></td>
                                                               <td><input type="text" name="email" id="email" size="40"><br></td>
                                                            </tr>
                                                            <tr>
                                                               <td valign="top"><label for="comment">Ihr Kommentar</label><br></td>
                                                               <td><textarea name="comment" id="comment" rows="10" cols="40"></textarea><br></td>
                                                            </tr>
                                                            <tr>
                                                               <td></td>
                                                               <td><input type="submit" value="Kommentar absenden"></td>
                                                            </tr>
                                                         </tbody>
                                                      </table>
                                                   </form>--><a href="https://www.galileo-press.de/feedback/produkt/3243/">>> Zum Feedback-Formular</a>
                                                </div>
                                             </td>
                                          </tr>
                                       </tbody>
                                    </table>
                                 </td>
                              </tr>
                              <tr>
                                 <td width="100%" class="start" colspan="1" height="22" align="center">
                                    <table width="100%" border="0" cellspacing="0" cellpadding="0">
                                       <tbody>
                                          <tr>
                                             <td width="25%"><a href="1997_15_001.html" class="navnav"> &lt;&lt; zurück</a></td>
                                             <td width="49%">
                                                <div align="center"><a class="navnav" href="#">&lt;top&gt;</a></div>
                                             </td>
                                             <td align="right" width="25%">
                                                <div align="right"><a href="1997_15_003.html" class="navnav">vor &gt;&gt;
                                                      </a></div>
                                             </td>
                                          </tr>
                                       </tbody>
                                    </table>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                  </div>
               </td>
               <td width="10" valign="top"></td>
               <td width="160" valign="top"><table border="0" cellpadding="0" cellspacing="0" width="160">
                  <tbody><tr>
                  <td>
                  <table border="0" cellpadding="0" cellspacing="0" width="100%">
                  <tr>
                  <td class="start" height="20" colspan="2">
                  &nbsp;<a href="https://www.galileo-press.de/?GPP=opvcs" class="autor">
                  <strong>Zum Katalog</strong></a>
                  </td>
                  </tr>
                  <tr>
                  <td valign="top" class="tbl4" width="2">
                  <img src="common/leer.gif" border="0" height="1" width="1"></td>
                  <td valign="top">
                  <table cellspacing="3">
                  <tr>
                  <td><a href="https://www.galileo-press.de/3243/?GPP=opvcs">
                  <img src="common/1997.png" width="118" height="90" border="0" align="left" hspace="4"
                  vspace="8" alt="Zum Katalog: Visual C# 2012" title="Zum Katalog: Visual C# 2012">
                  <br><br><strong>Visual C# 2012</strong><br><img src="common/pfeil_rechts5.gif" border="0"
                  alt="">Jetzt bestellen</a><br /><br />
                  </td>
                  </tr>
                  </table>
                  </td>
                  </tr>
                  </table>
                  </td>
                  </tr>
                  <tr>
                  <td><img src="common/leer.gif" height="2" width="1" border="0" /></img></td>
                  </tr>
                  <tr>
                  <td>
                  <table border="0" cellpadding="0" cellspacing="0" width="100%">
                  <tr>
                  <td class="start" height="20" colspan="2"><span class="autor"><strong>&nbsp;Ihre Meinung?</strong></a></td>
                  </tr>
                  <tr>
                  <td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1"
                  width="1"></td>
                  <td valign="top">
                  <table cellspacing="3">
                  <tr>
                  <td>Wie hat Ihnen das &lt;openbook&gt; gefallen?<br><a href="#kommentar"><img src="common/pfeil_rechts5.gif"
                  border="0" alt="">Ihre Meinung</a>
                  <br><br></td>
                  </tr>
                  </table>
                  </td>
                  </tr>
                  </table>
                  </td>
                  </tr>
                  <tr>
                  <td><img src="common/leer.gif" height="2" width="1" border="0" /></img></td>
                  </tr>
                  <tr>
                  <td>
                  </td>
                  </tr>
                  <tr>
                  <td><img src="common/leer.gif" height="2" width="1" border="0" /></img></td>
                  </tr>
                  <tr>
                  <td>
                  <table border="0" cellpadding="0" cellspacing="0" width="100%">
                  <tr>
                  <td class="start" height="20" colspan="2">&nbsp;<a href="https://www.galileo-press.de/?GPP=opvcs"
                  class="autor"><strong>Buchempfehlungen</strong></a></td>
                  </tr>
                  <tr>
                  <td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1"
                  width="1"></td><td valign="top">
                  <a href="http://www.galileo-press.de/3175/?GPP=opvcs">
                  <img src="common/1954.png" width="113" height="90" border="0" align="left" hspace="4"
                  vspace="8" alt="Zum Katalog: Professionell entwickeln mit Visual C# 2012"><br><br><br><br><br><br>&nbsp;Professionell<br>&nbsp;entwickeln mit<br>&nbsp;Visual C# 2012</a><br><br></td>
                  </tr>
                  <tr>
                  <td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1"
                  width="1"></td><td valign="top">
                  <a href="http://www.galileo-press.de/3179/?GPP=opvcs">
                  <img src="common/1956.png" width="118" height="90" border="0" align="left" hspace="4"
                  vspace="8" alt="Zum Katalog: Windows Presentation Foundation 4.5"><br><br><br><br><br><br><br>&nbsp;Windows Presentation<br>&nbsp;Foundation 4.5<br><br></td>
                  </tr>
                  <tr>
                  <td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1"
                  width="1"></td><td valign="top">
                  <a href="http://www.galileo-press.de/3196/?GPP=opvcs">
                  <img src="common/1968.png" width="111" height="90" border="0" align="left" hspace="4"
                  vspace="8" alt="Zum Katalog: Windows Store Apps mit XAML und C#"><br><br><br><br><br><br><br>&nbsp;Windows Store Apps<br>&nbsp;mit XAML und C#<br><br></td>
                  </tr>
                  <tr>
                  <td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1"
                  width="1"></td><td valign="top">
                  <a href="http://www.galileo-press.de/3189/?GPP=opvcs">
                  <img src="common/1960.png" width="110" height="90" border="0" align="left" hspace="4"
                  vspace="8" alt="Zum Katalog: Einstieg in Visual C# 2012"><br><br><br><br><br><br><br>&nbsp;Einstieg in<br>&nbsp;Visual C# 2012</a><br><br></td>
                  </tr>
                  <tr>
                  <td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1"
                  width="1"></td><td valign="top">
                  <a href="http://www.galileo-press.de/3214/?GPP=opvcs">
                  <img src="common/1967.png" width="110" height="90" border="0" align="left" hspace="4"
                  vspace="8" alt="Zum Katalog: Einstieg in WPF 4.5"><br><br><br><br><br><br><br>&nbsp;Einstieg in WPF 4.5</a><br><br></td>
                  </tr>
                  <tr>
                  <td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1"
                  width="1"></td><td valign="top">
                  <a href="http://www.galileo-press.de/2853/?GPP=opvcs">
                  <img src="common/1756.png" width="121" height="90" border="0" align="left" hspace="4"
                  vspace="8" alt="Zum Katalog: Schrödinger programmiert C++"><br><br><br><br><br><br><br>&nbsp;Schrödinger<br>&nbsp;programmiert C++</a><br><br></td>
                  </tr>
                  <tr>
                  <td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1"
                  width="1"></td><td valign="top">
                  <a href="http://www.galileo-press.de/2824/?GPP=opvcs">
                  <img src="common/1732.png" width="109" height="90" border="0" align="left" hspace="4"
                  vspace="8" alt="Zum Katalog: C++11 programmieren"><br><br><br><br><br><br><br>&nbsp;C++11 programmieren</a><br><br></td>
                  </tr>
                  </table></td>
                  </tr>
                  <tr>
                  <td><img src="common/leer.gif" height="2" width="1" border="0" /></img></td>
                  </tr>
                  <tr>
                  <td>
                  <table border="0" cellpadding="0" cellspacing="0" width="100%">
                  <tr>
                  <td class="start" height="20" colspan="2"><span class="autor"><strong>&nbsp;Shopping</strong></span></td>
                  </tr>
                  <tr>
                  <td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1"
                  width="1"></td>
                  <td valign="top">
                  <table cellspacing="3">
                  <tr>
                  <td><b>Versandkostenfrei</b> bestellen in Deutschland und &Ouml;sterreich<br><a href="https://www.galileo-press.de/hilfe/bestellung_6?GPP=opvcs"><img
                  src="common/pfeil_rechts5.gif" border="0" alt="Info">Info</a><br><br></td>
                  </tr>
                  </table>
                  </td>
                  </tr>
                  </table>
                  </td>
                  </tr>
                  </table>
                  </td>
                  </tr>
                  </tbody></table>
                  <br><br><hr align="center" width="70%"><br><div align="center">
                  <p class="standard"><b>Copyright © Galileo Press 2013</b><br>Für Ihren privaten Gebrauch
                  dürfen Sie die Online-Version natürlich ausdrucken. Ansonsten unterliegt das &lt;openbook&gt;
                  denselben Bestimmungen, wie die gebundene Ausgabe: Das Werk einschließlich aller seiner
                  Teile ist urheberrechtlich geschützt. Alle Rechte vorbehalten einschließlich der Vervielfältigung,
                  Übersetzung, Mikroverfilmung sowie Einspeicherung und Verarbeitung in elektronischen
                  Systemen.</p><br><a href="https://www.galileo-press.de/">[Galileo Computing]</a><br><br>Galileo
                  Press, Rheinwerkallee 4, 53227 Bonn, Tel.: 0228.42150.0, Fax 0228.42150.77, <a href="mailto:info@galileo-press.de">info@galileo-press.de</a></div><br><br>
               </td>
            </tr>
         </tbody>
      </table>
   </body>
</html>