-- ------------------------------------------------------------------------
-- 1.1) SQL KLAUSELN
-- ------------------------------------------------------------------------
-- REGION

-- GEBEN SIE FÜR KREUZFAHRTEN FOLGENDE WERTE AN:
-- LABEL, NAME, DISTANCE.

-- @LABEL -> CRUISES.LABEL
-- @NAME  -> SHIP.NAME
-- @ROUTE_NAME -> ROUTES_JT.NAME
-- @DISTANCE   -> ROUTES_JT.DISTANCE

-- TABLES: CRUISES, CRUISE_HAS_ROUTES_JT, ROUTES_JT

WITH ROUTES_DATA AS (SELECT CRUISE_ID, SUM(DISTANCE) DISTANCE
                     FROM CRUISE_HAS_ROUTES_JT CHRJ2
                              JOIN ROUTES_JT R ON R.DEPARTURE_HARBOR_ID = CHRJ2.DEPARTURE_HARBOR_ID AND
                                                  R.ARRIVAL_HARBOR_ID = CHRJ2.ARRIVAL_HARBOR_ID
                     GROUP BY CRUISE_ID)
SELECT C.LABEL, S.NAME, RD.DISTANCE
FROM CRUISES C
         JOIN SHIPS S ON C.SHIP_ID = S.SHIP_ID
         JOIN ROUTES_DATA RD ON RD.CRUISE_ID = C.CRUISE_ID;

SELECT C.LABEL, S.NAME, RJ.NAME, RJ.DISTANCE
FROM CRUISES C
         JOIN SHIPS S ON C.SHIP_ID = S.SHIP_ID
         JOIN CRUISE_HAS_ROUTES_JT CHRJ ON C.CRUISE_ID = CHRJ.CRUISE_ID
         JOIN ROUTES_JT RJ
              ON CHRJ.DEPARTURE_HARBOR_ID = RJ.DEPARTURE_HARBOR_ID AND CHRJ.ARRIVAL_HARBOR_ID = RJ.ARRIVAL_HARBOR_ID;

-- ENDREGION

-- ------------------------------------------------------------------------
-- 1.2) SQL KLAUSELN
-- ------------------------------------------------------------------------
-- REGION

-- GEBEN SIE FÜR KREUZFAHRTEN FOLGENDE WERTE AN:
-- LABEL, DISTANCE, DISTANCE_CLASSIFICATION

-- @LABEL -> CRUISES.LABEL
-- @DISTANCE -> DIE WÄHREND DER KREUZFAHRT ZURÜCKGELEGTE LÄNGE DER SUMME
--              DER STRECKEN

-- @DISTANCE_CLASSFICATION -> ENTSPRECHEND DER ZURÜCKGELEGTEN STRECKE SOLL
--                            EINE KLASSIFIZIERUNG ANGEGEBEN WERDEN:

--     0    < DISTANCE <= 1000     "SHORT_CRUISE"
--     1000 < DISTANCE <= 2000     "MEDIUM_CRUISE"
--     2000 < DISTANCE <= ....     "LONG_CRUISE"

WITH ROUTES_DATA AS (SELECT CRUISE_ID, SUM(DISTANCE) DISTANCE
                     FROM CRUISE_HAS_ROUTES_JT CHRJ2
                              JOIN ROUTES_JT RJ ON CHRJ2.DEPARTURE_HARBOR_ID = RJ.DEPARTURE_HARBOR_ID AND
                                                   CHRJ2.ARRIVAL_HARBOR_ID = RJ.ARRIVAL_HARBOR_ID
                     GROUP BY CRUISE_ID)
SELECT C.LABEL,
       RD.DISTANCE,
       CASE
           WHEN RD.DISTANCE <= 1000 THEN 'SHORT_CRUISE'
           WHEN RD.DISTANCE > 1000 AND RD.DISTANCE <= 2000 THEN 'MEDIUM_CRUISE'
           WHEN RD.DISTANCE > 2000 THEN 'LONG_CRUISE'
           END DISTANCE_CLASSIFICATION
FROM CRUISES C
         JOIN ROUTES_DATA RD
              ON RD.CRUISE_ID = C.CRUISE_ID;

SELECT C.LABEL          AS LABEL,
       SUM(RJ.DISTANCE) AS DISTANCE,
       CASE
           WHEN SUM(RJ.DISTANCE) > 0 AND SUM(RJ.DISTANCE) <= 1000 THEN 'SHORT_CRUISE'
           WHEN SUM(RJ.DISTANCE) > 1000 AND SUM(RJ.DISTANCE) <= 2000 THEN 'MEDIUM_CRIUSE'
           ELSE 'LONG_CRUISE' END
                        AS DISTANCE_CLASSIFICATION
FROM CRUISES C
         JOIN CRUISE_HAS_ROUTES_JT CHRJ ON C.CRUISE_ID = CHRJ.CRUISE_ID
         JOIN ROUTES_JT RJ
              ON CHRJ.DEPARTURE_HARBOR_ID = RJ.DEPARTURE_HARBOR_ID AND
                 CHRJ.ARRIVAL_HARBOR_ID = RJ.ARRIVAL_HARBOR_ID
GROUP BY C.LABEL;

-- ENDREGION

-- ------------------------------------------------------------------------
-- 1.3) SUBSELECT
-- ------------------------------------------------------------------------
-- REGION

-- ERMITTELN SIE DIE ANGESTELLTENGRUPPE IN DER ZUR ZEIT DIE MEISTEN
-- ANGESTELLTEN BESCHAEFTIGT SIND.

-- AUSGABE: EMPLOYEE_TYPE, EMPLOYEE_COUNT

-- TABELLEN: EMPLOYEE_ST

SELECT EMPLOYEE_TYPE, COUNT(EMPLOYEE_ID) EMPLOYEE_COUNT
FROM EMPLOYEE_ST
GROUP BY EMPLOYEE_TYPE
HAVING COUNT(EMPLOYEE_ID) = (SELECT MAX(COUNT(EMPLOYEE_ID)) EMPLOYEE_COUNT
                             FROM EMPLOYEE_ST
                             GROUP BY EMPLOYEE_TYPE);

SELECT COUNT(EMPLOYEE_ID), EMPLOYEE_TYPE
FROM EMPLOYEE_ST
GROUP BY EMPLOYEE_TYPE
HAVING COUNT(EMPLOYEE_ID) = (SELECT MAX(EMPLOYEE_COUNT) MAX_EMPLOYEE_COUNT
                             FROM (SELECT COUNT(EMPLOYEE_ID) EMPLOYEE_COUNT, EMPLOYEE_TYPE
                                   FROM EMPLOYEE_ST
                                   GROUP BY EMPLOYEE_TYPE));

-- ENDREGION

-- ------------------------------------------------------------------------
-- 1.4) SUBSELECT
-- ------------------------------------------------------------------------
-- REGION

-- FUER WELCHES LAND WERDEN DIE MEISTEN HAEFEN GESPEICHERT. GEBEN SIE DIE
-- FOLGENDEN SPALTEN AUS:

-- AUSGABE: COUNTRY, HARBOR_COUNT

-- TABELLEN: HARBORS

SELECT COUNTRY, COUNT(COUNTRY)
FROM HARBORS
GROUP BY COUNTRY
HAVING COUNT(COUNTRY) = (SELECT MAX(COUNT(COUNTRY))
                         FROM HARBORS
                         GROUP BY COUNTRY);

SELECT COUNTRY, MAX_HARBOR_COUNT
FROM (SELECT COUNT(HARBOR_ID) HARBOR_COUNT, COUNTRY FROM HARBORS GROUP BY COUNTRY)
         JOIN (SELECT MAX(COUNT(HARBOR_ID)) MAX_HARBOR_COUNT FROM HARBORS GROUP BY COUNTRY)
              ON MAX_HARBOR_COUNT = HARBOR_COUNT;

-- ENDREGION

-- ------------------------------------------------------------------------
-- 1.5) SUBSELECT
-- ------------------------------------------------------------------------
-- REGION

-- GEBEN SIE DIE UMSATZHOECHSTE BUCHUNG AUS. BERUECKSICHTIGEN SIE NUR
-- BUCHUNGEN DIE ZWISCHEN 2007 UND 2020 ABGESCHLOSSEN WURDEN.

-- AUSGABE: BOOKING_ID, TURNOVER

-- @TURNOVER: BESCHREIBT DEN GESAMTEN UMSATZ FUER EINE BUCHUNG.

-- HINWEIS: JEDER CRUISE_HAS_BOOKINGS_JT DATENSATZ BESCHREIBT WELCHER
--          REISENDE, WELCHE KABINE FUER WELCHE KREUZFAHRT ZU WELCHEM
--          PREIS ERSTANDEN IM RAHMEN WELCHER BUCHUNG ERSTANDEN HAT.

--          EINE BUCHUNG KANN AUS MEHREREN CRUISE_HAS_BOOKING_JT
--          DATENSAETZEN BESTEHEN!

-- TABELLEN: CRUISE_HAS_BOOKINGS_JT, BOOKINGS

SELECT BOOKING_ID, SUM(PRICE) TURNOVER
FROM CRUISE_HAS_BOOKINGS_JT
GROUP BY BOOKING_ID
HAVING SUM(PRICE) = (SELECT MAX(SUM(PRICE))
                     FROM CRUISE_HAS_BOOKINGS_JT CHBJ
                              JOIN BOOKINGS B ON CHBJ.BOOKING_ID = B.BOOKING_ID
                     WHERE B.BOOKED_AT > '1.1.2007'
                       AND B.BOOKED_AT < '1.1.2020'
                     GROUP BY CHBJ.BOOKING_ID);



SELECT BOOKING_ID, SUM(PRICE)
FROM CRUISE_HAS_BOOKINGS_JT
GROUP BY BOOKING_ID;

-- ENDREGION

-- ------------------------------------------------------------------------
-- 1.6) SUBSELECT
-- ------------------------------------------------------------------------
-- REGION

-- IN WELCHER ROLLE ARBEITEN DIE MEISTEN MITARBEITER AUF DER KREUZFAHRT MIT
-- DEN MEISTEN MITARBEITERN?

-- GEBEN SIE FOLGENDEN SPALTENWERTE AUS: CRUISE_ID, EMPLOYEE_ROLE, EMPLOYEE_COUNT

-- @EMPLOYEE_COUNT: ANZAHL DER ANGESTELLTEN DIE IN DER ENTSPRECHENDEN ROLLE
--                  BESCHAEFTIGT SIND.

-- TABELLEN: CRUISE_HAS_EMPLOYEES

with CRUISE_ID_MAX_EMPLOYEES AS (select CRUISE_ID
                                 from CRUISE_HAS_EMPLOYEES_JT
                                 group by CRUISE_ID
                                 having count(EMPLOYEE_ID) = (select max(count(EMPLOYEE_ID))
                                                              from CRUISE_HAS_EMPLOYEES_JT
                                                              group by CRUISE_ID))
select *
from CRUISE_HAS_EMPLOYEES_JT
 ;



SELECT CHEJ.CRUISE_ID, CHEJ.EMPLOYEE_ROLE, SUB.EMPLOYEE_COUNT
FROM (SELECT CRUISE_ID, COUNT(EMPLOYEE_ROLE) AS EMPLOYEE_COUNT
      FROM CRUISE_HAS_EMPLOYEES_JT
      GROUP BY CRUISE_ID
      HAVING COUNT(EMPLOYEE_ROLE) =
             (SELECT MAX(COUNT(EMPLOYEE_ROLE)) FROM CRUISE_HAS_EMPLOYEES_JT GROUP BY CRUISE_ID)) SUB
         JOIN CRUISE_HAS_EMPLOYEES_JT CHEJ ON CHEJ.CRUISE_ID = SUB.CRUISE_ID;

SELECT CRUISE_ID, EMPLOYEE_ROLE, COUNT(EMPLOYEE_ROLE)
FROM CRUISE_HAS_EMPLOYEES_JT
GROUP BY CRUISE_ID, EMPLOYEE_ROLE
HAVING CRUISE_ID IN (SELECT CRUISE_ID
                     FROM CRUISE_HAS_EMPLOYEES_JT
                     GROUP BY CRUISE_ID
                     HAVING COUNT(CRUISE_ID) =
                            (SELECT MAX(COUNT(CRUISE_ID)) FROM CRUISE_HAS_EMPLOYEES_JT GROUP BY CRUISE_ID))
   AND COUNT(EMPLOYEE_ROLE) =
       (SELECT MAX(COUNT(EMPLOYEE_ROLE)) FROM CRUISE_HAS_EMPLOYEES_JT GROUP BY CRUISE_ID, EMPLOYEE_ROLE)
ORDER BY CRUISE_ID;


SELECT CRUISE_ID, EMPLOYEE_ROLE, COUNT(EMPLOYEE_ROLE) EMPLOYEE_COUNT
FROM CRUISE_HAS_EMPLOYEES_JT
WHERE EMPLOYEE_ROLE IN
      (SELECT EMPLOYEE_ROLE
       FROM CRUISE_HAS_EMPLOYEES_JT
       GROUP BY EMPLOYEE_ROLE
       HAVING COUNT(EMPLOYEE_ROLE) = (SELECT MAX(COUNT(EMPLOYEE_ROLE))
                                      FROM CRUISE_HAS_EMPLOYEES_JT
                                      GROUP BY EMPLOYEE_ROLE))
  AND CRUISE_ID IN (SELECT CRUISE_ID INNER_CRUISE_ID
                    FROM CRUISE_HAS_EMPLOYEES_JT CHEJ2
                    GROUP BY CRUISE_ID
                    HAVING COUNT(CRUISE_ID) = (SELECT MAX(COUNT(CRUISE_ID))
                                               FROM CRUISE_HAS_EMPLOYEES_JT
                                               GROUP BY CRUISE_ID))
GROUP BY CRUISE_ID, EMPLOYEE_ROLE
ORDER BY CRUISE_ID ASC, EMPLOYEE_COUNT DESC, EMPLOYEE_ROLE ASC;

WITH MAX_EMPLOYEE_COUNT AS (SELECT CRUISE_ID
                            FROM CRUISE_HAS_EMPLOYEES_JT
                            GROUP BY CRUISE_ID
                            HAVING COUNT(EMPLOYEE_ID) = (SELECT MAX(EMPLOYEE_COUNT) AS MAX_EMPLOYEE_COUNT
                                                         FROM (SELECT COUNT(EMPLOYEE_ID) AS EMPLOYEE_COUNT
                                                               FROM CRUISE_HAS_EMPLOYEES_JT
                                                               GROUP BY CRUISE_ID)))

SELECT CRUISE_ID, EMPLOYEE_ROLE, COUNT(EMPLOYEE_ID) AS EMPLOYEE_COUNT
FROM CRUISE_HAS_EMPLOYEES_JT
GROUP BY CRUISE_ID, EMPLOYEE_ROLE
HAVING CRUISE_ID IN (SELECT * FROM MAX_EMPLOYEE_COUNT)
   AND COUNT(EMPLOYEE_ID) = (SELECT MAX(EMPLOYEE_COUNT)
                             FROM (SELECT CRUISE_ID, EMPLOYEE_ROLE, COUNT(EMPLOYEE_ID) AS EMPLOYEE_COUNT
                                   FROM CRUISE_HAS_EMPLOYEES_JT
                                   WHERE CRUISE_ID IN (SELECT *
                                                       FROM (SELECT CRUISE_ID
                                                             FROM CRUISE_HAS_EMPLOYEES_JT
                                                             GROUP BY CRUISE_ID
                                                             HAVING COUNT(EMPLOYEE_ID) =
                                                                    (SELECT MAX(EMPLOYEE_COUNT) AS MAX_EMPLOYEE_COUNT
                                                                     FROM (SELECT COUNT(EMPLOYEE_ID) AS EMPLOYEE_COUNT
                                                                           FROM CRUISE_HAS_EMPLOYEES_JT
                                                                           GROUP BY CRUISE_ID))))
                                   GROUP BY CRUISE_ID, EMPLOYEE_ROLE));

---------------------------------------------------------------------------------

-- MAX_EMPLOYEE_COUNT
SELECT MAX(EMPLOYEE_COUNT)
FROM (SELECT COUNT(EMPLOYEE_ROLE) EMPLOYEE_COUNT
      fROM CRUISE_HAS_EMPLOYEES_JT
      GROUP BY CRUISE_ID);

-- Cruise_ids
SELECT COUNT(EMPLOYEE_ID) EMPLOYEE_COUNT, CRUISE_ID
FROM CRUISE_HAS_EMPLOYEES_JT
GROUP BY CRUISE_ID
HAVING COUNT(EMPLOYEE_ROLE) = (SELECT MAX(EMPLOYEE_COUNT)
                               FROM (SELECT COUNT(EMPLOYEE_ROLE) EMPLOYEE_COUNT
                                     fROM CRUISE_HAS_EMPLOYEES_JT
                                     GROUP BY CRUISE_ID));

-- insgesamt 6 waiter bei 1 und 4
SELECT MAX(COUNT(EMPLOYEE_ID))
FROM CRUISE_HAS_EMPLOYEES_JT CHEJ
         JOIN (SELECT COUNT(EMPLOYEE_ID) EMPLOYEE_COUNT, CRUISE_ID
               FROM CRUISE_HAS_EMPLOYEES_JT
               GROUP BY CRUISE_ID
               HAVING COUNT(EMPLOYEE_ROLE) = (SELECT MAX(EMPLOYEE_COUNT)
                                              FROM (SELECT COUNT(EMPLOYEE_ROLE) EMPLOYEE_COUNT
                                                    fROM CRUISE_HAS_EMPLOYEES_JT
                                                    GROUP BY CRUISE_ID))) SS ON CHEJ.CRUISE_ID = SS.CRUISE_ID
GROUP BY EMPLOYEE_ROLE, SS.CRUISE_ID;

SELECT ss.CRUISE_ID, COUNT(EMPLOYEE_ID) EMPLOYEE_COUNT, EMPLOYEE_ROLE
FROM CRUISE_HAS_EMPLOYEES_JT CHEJ
         JOIN (SELECT COUNT(EMPLOYEE_ID) EMPLOYEE_COUNT, CRUISE_ID
               FROM CRUISE_HAS_EMPLOYEES_JT
               GROUP BY CRUISE_ID
               HAVING COUNT(EMPLOYEE_ROLE) = (SELECT MAX(EMPLOYEE_COUNT)
                                              FROM (SELECT COUNT(EMPLOYEE_ROLE) EMPLOYEE_COUNT
                                                    fROM CRUISE_HAS_EMPLOYEES_JT
                                                    GROUP BY CRUISE_ID))) ss ON CHEJ.CRUISE_ID = SS.CRUISE_ID
GROUP BY ss.CRUISE_ID, EMPLOYEE_ROLE
HAVING COUNT(EMPLOYEE_ID) = (SELECT MAX(COUNT(EMPLOYEE_ID)) EMPLOYEE_COUNT
                             FROM CRUISE_HAS_EMPLOYEES_JT CHEJ
                                      JOIN (SELECT COUNT(EMPLOYEE_ID) EMPLOYEE_COUNT, CRUISE_ID
                                            FROM CRUISE_HAS_EMPLOYEES_JT
                                            GROUP BY CRUISE_ID
                                            HAVING COUNT(EMPLOYEE_ROLE) = (SELECT MAX(EMPLOYEE_COUNT)
                                                                           FROM (SELECT COUNT(EMPLOYEE_ROLE) EMPLOYEE_COUNT
                                                                                 fROM CRUISE_HAS_EMPLOYEES_JT
                                                                                 GROUP BY CRUISE_ID))) ss
                                           ON CHEJ.CRUISE_ID = SS.CRUISE_ID
                             GROUP BY ss.CRUISE_ID, EMPLOYEE_ROLE);


-- ENDREGION

-- ------------------------------------------------------------------------
-- 2.1) SUBSELECT: WITH KLAUSEL
-- ------------------------------------------------------------------------
-- REGION

--  ZUR ERSTELLUNG DER JAEHRLICHEN BILANZ SOLL FUER DIE GESPEICHERTEN KREUZ-
--  FAHRTEN EIN REPORT ERSTELLT WERDEN

-- ERMITTELN SIE FUER JEDE KREUZFAHRT DIE FOLGENDEN WERTE:

-- AUSGABE: CRUISE_ID, LABEL, DATE_OF_DEPARTUER, DURATION, EMPLOYEE_COUNT,
--          BOOKING_COUNT, SALES, BOOKED_CABINS

-- @DURATION: ANZAHL DER TAGE
-- @EMPLOYEE_COUNT: ANZAHL DER ANGESTELLTEN
-- @BOOKING_COUNT: ANZAHL DER BUCHUNGEN
-- @SALES: DURCH BUCHUNGEN GENERIERTER UMSATZ
-- @BOOKED_CABINS: DIE ANZAHL DER GEBUCHTEN KABINEN
-- @DISTANCE:

-- SORTIEREN SIE DAS ERGEBNIS NACH DER BEZEICHNUNG DER KREUZFAHRTEN

-- TABELLEN: CRUISES, CRUISE_HAS_EMPLOYEES_JT, CRUISE_HAS_BOOKINGS_JT

WITH EMPLOYEE_DATA AS (SELECT CRUISE_ID, COUNT(EMPLOYEE_ID) AS EMPLOYEE_COUNT
                       FROM CRUISE_HAS_EMPLOYEES_JT
                       GROUP BY CRUISE_ID),
     BOOKING_DATA AS (SELECT CRUISE_ID,
                             COUNT(DISTINCT BOOKING_ID) AS BOOKING_COUNT,
                             SUM(PRICE)                 AS SALES,
                             COUNT(DISTINCT CABIN_NR)   AS BOOKED_CABINS
                      FROM CRUISE_HAS_BOOKINGS_JT
                      GROUP BY CRUISE_ID),
     ROUTE_DATA AS (SELECT CRUISE_ID, SUM(DISTANCE) AS DISTANCE
                    FROM CRUISE_HAS_ROUTES_JT CHRJ
                             JOIN ROUTES_JT RJ ON CHRJ.DEPARTURE_HARBOR_ID = RJ.DEPARTURE_HARBOR_ID AND
                                                  CHRJ.ARRIVAL_HARBOR_ID = RJ.ARRIVAL_HARBOR_ID
                    GROUP BY CRUISE_ID)
SELECT C.CRUISE_ID                             AS CRUISE_ID,
       C.LABEL                                 AS LABEL,
       C.DATE_OF_DAPARTURE                     AS DATE_OF_DEPARTURE,
       C.DATE_OF_ARRIVAL - C.DATE_OF_DAPARTURE AS DURATION,
       COALESCE(ED.EMPLOYEE_COUNT, 0)          AS EMPLOYEE_COUNT,
       COALESCE(BD.BOOKING_COUNT, 0)           AS BOOKING_COUNT,
       COALESCE(BD.SALES, 0)                   AS SALES,
       COALESCE(BD.BOOKED_CABINS, 0)           AS BOOKED_CABINS,
       COALESCE(RD.DISTANCE, 0)                AS DISTANCE
FROM CRUISES C
         JOIN EMPLOYEE_DATA ED
              ON C.CRUISE_ID = ED.CRUISE_ID
         JOIN BOOKING_DATA BD ON C.CRUISE_ID = BD.CRUISE_ID
         JOIN ROUTE_DATA RD ON C.CRUISE_ID = RD.CRUISE_ID
ORDER BY C.LABEL ASC;


WITH EMPLOYEE_COUNT_DATA AS (SELECT COUNT(EMPLOYEE_ID) AS EMPLOYEE_COUNT, CHEJ.CRUISE_ID
                             FROM CRUISE_HAS_EMPLOYEES_JT CHEJ
                             GROUP BY CHEJ.CRUISE_ID),
     BOOKING_COUNT_DATA AS (SELECT CRUISE_ID,
                                   COUNT(UNIQUE BOOKING_ID) AS BOOKING_COUNT,
                                   SUM(PRICE)               AS SALES,
                                   COUNT(UNIQUE CABIN_NR)   AS BOOKED_CABINS
                            FROM CRUISE_HAS_BOOKINGS_JT
                            GROUP BY CRUISE_ID),
     ROUTES_DATA AS (SELECT CRUISE_ID, SUM(ROUTES_JT.DISTANCE) AS DISTANCE
                     FROM CRUISE_HAS_ROUTES_JT
                              JOIN ROUTES_JT
                                   ON CRUISE_HAS_ROUTES_JT.DEPARTURE_HARBOR_ID = ROUTES_JT.DEPARTURE_HARBOR_ID AND
                                      CRUISE_HAS_ROUTES_JT.ARRIVAL_HARBOR_ID = ROUTES_JT.ARRIVAL_HARBOR_ID
                     GROUP BY CRUISE_ID)

SELECT C.CRUISE_ID,
       C.LABEL,
       C.DATE_OF_DAPARTURE,
       C.DATE_OF_ARRIVAL - C.DATE_OF_DAPARTURE AS DURATION,
       COALESCE(ECD.EMPLOYEE_COUNT, 0)         AS EMPLOYEE_COUNT,
       COALESCE(BCD.BOOKING_COUNT, 0)          AS BOOKING_COUNT,
       COALESCE(BCD.SALES, 0)                  AS SALES,
       COALESCE(BCD.BOOKED_CABINS, 0)          AS BOOKED_CABINS,
       COALESCE(RD.DISTANCE, 0)                AS DISTANCE
FROM CRUISES C
         LEFT JOIN EMPLOYEE_COUNT_DATA ECD ON C.CRUISE_ID = ECD.CRUISE_ID
         LEFT JOIN BOOKING_COUNT_DATA BCD ON C.CRUISE_ID = BCD.CRUISE_ID
         LEFT JOIN ROUTES_DATA RD ON C.CRUISE_ID = RD.CRUISE_ID
ORDER BY C.LABEL ASC;


-- ENDREGION

-- ------------------------------------------------------------------------
-- 2.2) EXISTS KLAUSEL
-- ------------------------------------------------------------------------
-- REGION

-- GEBEN SIE ALLE SCHIFFSTYPEN AN, DIE ZUMINDESTENS EINEM KREUZFAHRSCHIFF
-- ZUGEORDNET SIND.

-- HINWEIS: ALS KREUZFAHRTSCHIFFE WERDEN SCHIFFE BEZEICHNET DIE BEI
--          KREUZFAHRTEN EINGESETZT WERDEN

-- AUSGABE: TYPE


-- TABLES: E_SHIP_CLASSIFICATION, SHIPS, CRUISES

SELECT *
FROM E_SHIP_CLASSIFICATION ESC
WHERE EXISTS(SELECT * FROM SHIPS WHERE SHIP_CLASSIFICATION = ESC.TYPE);

SELECT *
FROM E_SHIP_CLASSIFICATION;

-- ENDREGION

-- ------------------------------------------------------------------------
-- 2.3) EXISTS KLAUSEL
-- ------------------------------------------------------------------------
-- REGION

-- FINDEN SIE ALLE HÄFEN DIE ZUMINDESTENS AUF EINER ROUTE LIEGEN.

-- AUSGABE: HARBOR_ID, NAME, COUNTRY


-- TABLES: HARBORS, ROUTES_JT

SELECT HARBOR_ID, NAME, COUNTRY
FROM HARBORS H
WHERE EXISTS(SELECT * FROM ROUTES_JT R WHERE H.HARBOR_ID IN (R.ARRIVAL_HARBOR_ID, R.DEPARTURE_HARBOR_ID));


-- ENDREGION

-- ------------------------------------------------------------------------
-- 2.4) EXISTS KLAUSEL
-- ------------------------------------------------------------------------
-- REGION

-- FINDEN SIE ALLE HÄFEN DIE AUF KEINER ROUTE LIEGEN.

-- AUSGABE: HARBOR_ID, NAME, COUNTRY
-- HINWEIS: ES GIBT KEINE ROUTE FÜR DIE DER DEPARTURE_HARBOR ODER ARRIVAL_HARBOR
--          MIT DEM HAFEN ÜBEREINSTIMMEN


-- TABLES: HARBORS, ROUTES_JT

SELECT HARBOR_ID, NAME, COUNTRY
FROM HARBORS H
WHERE NOT EXISTS(SELECT * FROM ROUTES_JT R WHERE H.HARBOR_ID IN (R.DEPARTURE_HARBOR_ID, R.ARRIVAL_HARBOR_ID));

-- ENDREGION

-- ------------------------------------------------------------------------
-- 2.5) EXISTS KLAUSEL
-- ------------------------------------------------------------------------
-- REGION

-- FINDEN SIE ALLE CRUISES, DIE ZUMINDESTENS EINMAL GEBUCHT WORDEN SIND.

-- AUSGABE: CRUISE_ID, LABEL

-- TABLES: CRUISES, CRUISE_HAS_BOOKINGS_JT

SELECT CRUISE_ID, LABEL
FROM CRUISES C
WHERE EXISTS(SELECT * FROM CRUISE_HAS_BOOKINGS_JT CHBJ WHERE C.CRUISE_ID = CHBJ.CRUISE_ID);

-- ENDREGION

-- ------------------------------------------------------------------------
-- 2.6) EXISTS KLAUSEL
-- ------------------------------------------------------------------------
-- REGION

-- FINDEN SIE ALLE CRUISES, FÜR DIE KEINE BUCHUNGEN VORLIEGEN.

-- AUSGABE: CRUISE_ID, LABEL

-- TABLES: CRUISES, CRUISE_HAS_BOOKINGS_JT

SELECT CRUISE_ID, LABEL
FROM CRUISES C
WHERE NOT EXISTS(SELECT * FROM CRUISE_HAS_BOOKINGS_JT CHBJ WHERE C.CRUISE_ID = CHBJ.CRUISE_ID);

-- ENDREGION

-- ------------------------------------------------------------------------
-- 2.7) EXISTS KLAUSEL
-- ------------------------------------------------------------------------
-- REGION

-- GEBEN SIE ALLE SCHIFFE AUS, DIE KEINER CRUISE ZUGEORDNET SIND.

-- AUSGABE: SHIP_ID, NAME
--
-- @SHIP_ID -> SHIPS.SHIP_ID
-- @NAME    -> SHIPS.NAME

-- TABELLEN: SHIPS, CRUISES

SELECT SHIP_ID, NAME
FROM SHIPS S
WHERE NOT EXISTS(SELECT * FROM CRUISES C WHERE S.SHIP_ID = C.SHIP_ID);

-- ENDREGION

-- ------------------------------------------------------------------------
-- 2.8) EXISTS KLAUSEL
-- ------------------------------------------------------------------------
-- REGION

-- FINDEN SIE ALLE KREUZFAHRTEN DIE UNTERSCHIEDLICHE KONTINENTE ANFAHREN

-- AUSGABE: CRUISE_ID, LABEL

-- TABELLEN: CRUISES, CRUISES_HAS_ROUTES_JT, ROUTES, HARBORS


-- HINWEIS: ES EXISTIERT MINDESTENS EINE TEILSTRECKE DER KREUZFAHRT DEREN
--          ABFAHRTS- UND ANKUNFTSHAFEN AUF UNTERSCHIEDLICHEN CONTINENTEN LIEGT

SELECT CRUISE_ID, LABEL
FROM CRUISES C
WHERE EXISTS(SELECT *
             FROM CRUISE_HAS_ROUTES_JT CHRJ
                      JOIN ROUTES_JT RJ ON RJ.DEPARTURE_HARBOR_ID = CHRJ.DEPARTURE_HARBOR_ID AND
                                           RJ.ARRIVAL_HARBOR_ID = CHRJ.ARRIVAL_HARBOR_ID
                      JOIN HARBORS H ON RJ.ARRIVAL_HARBOR_ID = H.HARBOR_ID
                      JOIN HARBORS H2 ON RJ.DEPARTURE_HARBOR_ID = H2.HARBOR_ID
             WHERE C.CRUISE_ID = CHRJ.CRUISE_ID
               AND H2.CONTINENT != H.CONTINENT);

SELECT DISTINCT C.CRUISE_ID, C.LABEL
FROM CRUISES C
         JOIN CRUISE_HAS_ROUTES_JT CHRJ ON C.CRUISE_ID = CHRJ.CRUISE_ID
WHERE EXISTS(SELECT *
             FROM ROUTES_JT R
                      JOIN HARBORS H1 ON H1.HARBOR_ID = R.ARRIVAL_HARBOR_ID
                      JOIN HARBORS H2 ON H2.HARBOR_ID = R.DEPARTURE_HARBOR_ID
             WHERE H1.CONTINENT <> H2.CONTINENT
               AND ((CHRJ.ARRIVAL_HARBOR_ID = H1.HARBOR_ID
                 AND CHRJ.DEPARTURE_HARBOR_ID = H2.HARBOR_ID)));

SELECT C.CRUISE_ID, C.LABEL
FROM CRUISES C
WHERE EXISTS(SELECT CHR.CRUISE_ID, COUNT(UNIQUE CONTINENT)
             FROM CRUISE_HAS_ROUTES_JT CHR
                      JOIN HARBORS H ON H.HARBOR_ID IN (CHR.DEPARTURE_HARBOR_ID, CHR.ARRIVAL_HARBOR_ID)
             WHERE C.CRUISE_ID = CHR.CRUISE_ID
             GROUP BY CHR.CRUISE_ID
             HAVING COUNT(UNIQUE CONTINENT) > 1);


-- ENDREGION

-- ------------------------------------------------------------------------
-- 2.8) EXISTS KLAUSEL
-- ------------------------------------------------------------------------
-- REGION

-- BESTIMMEN SIE DIE ROUTE MIT DEM HÖCHSTEN WERT FÜR DIE STRECKENLÄNGE
-- (DISTANCE).

-- AUSGABE: NAME, DISTANCE

-- TABELLEN: ROUTES_JT


-- HINWEIS: ES GIBT KEINE ROUTE MIT EINEM HÖHEREN WERT DER STRECKENLÄNGE (DISTANCE)

SELECT *
FROM ROUTES_JT R
WHERE NOT EXISTS(SELECT * FROM ROUTES_JT R2 WHERE R2.DISTANCE > R.DISTANCE);

-- ENDREGION

-- ------------------------------------------------------------------------
-- 2.9) EXISTS KLAUSEL
-- ------------------------------------------------------------------------
-- REGION

-- FINDEN SIE ALLE KREUZFAHRTEN, DIE AUF JEDER ZUGEORDNETEN TEILSTRECKE MEHR
-- ALS 500 KM ZURÜCKLEGT.

-- AUSGABE: CRUISE_ID, LABEL

-- TABELLEN: CRUISES, ROUTES_JT, CRUISE_HAS_ROUTES_JT


-- HINWEIS: KEINE, DER DER KREUZFAHRT ZUGEORDNETE TEILSTRECKE IST KÜRZER ALS 500 KM.

SELECT *
FROM CRUISES C
WHERE NOT EXISTS(SELECT *
                 FROM CRUISE_HAS_ROUTES_JT CHRJ
                          JOIN ROUTES_JT RJ ON CHRJ.DEPARTURE_HARBOR_ID = RJ.DEPARTURE_HARBOR_ID AND
                                               CHRJ.ARRIVAL_HARBOR_ID = RJ.ARRIVAL_HARBOR_ID
                 WHERE C.CRUISE_ID IN CHRJ.CRUISE_ID
                   AND RJ.DISTANCE <= 500);

SELECT C.CRUISE_ID, C.LABEL
FROM CRUISES C
WHERE NOT EXISTS(SELECT *
                 FROM CRUISE_HAS_ROUTES_JT CHRJ
                          JOIN ROUTES_JT RJ ON CHRJ.DEPARTURE_HARBOR_ID = RJ.DEPARTURE_HARBOR_ID AND
                                               CHRJ.ARRIVAL_HARBOR_ID = RJ.ARRIVAL_HARBOR_ID
                 WHERE RJ.DISTANCE <= 500
                   AND C.CRUISE_ID = CHRJ.CRUISE_ID);

-- ENDREGION

-- ------------------------------------------------------------------------
-- 2.10) EXISTS KLAUSEL
-- ------------------------------------------------------------------------
-- REGION

-- GESUCHT SIND LÄNDER DEREN HÄFEN NICHT ALLE AUF REISEROUTEN LIEGEN.

-- AUSGABE: NAME

-- TABELLEN: E_COUNTRIES, HARBORS, ROUTES_JT

SELECT NAME
FROM E_COUNTRIES E
WHERE EXISTS(SELECT *
             FROM HARBORS H
             WHERE E.NAME = H.COUNTRY
               AND NOT EXISTS(SELECT *
                              FROM ROUTES_JT R
                              WHERE H.HARBOR_ID = R.ARRIVAL_HARBOR_ID
                                 OR H.HARBOR_ID = R.DEPARTURE_HARBOR_ID));


SELECT E.NAME
FROM E_COUNTRIES E
WHERE EXISTS(SELECT *
             FROM HARBORS H
             WHERE NOT EXISTS(SELECT *
                              FROM ROUTES_JT R
                              WHERE H.HARBOR_ID IN (R.DEPARTURE_HARBOR_ID, R.ARRIVAL_HARBOR_ID))
               AND H.COUNTRY = E.NAME);
-- ENDREGION


-- ------------------------------------------------------------------------
-- 2.11) EXISTS KLAUSEL
-- ------------------------------------------------------------------------
-- REGION

-- WELCHES SCHIFF WIRD BEI DEN MEISTEN KREUZFAHRTEN EINGESETZT?

-- AUSGABE: SHIP_ID, NAME

-- TABELLEN: CRUISE, SHIP

-- REGION QUERY1: GROUP BY


-- HINWEIS: ES GIBT KEIN SCHIFF DAS AUF MEHR KREUZFAHRTEN EINGESETZT
--          WORDEN IST

SELECT S.SHIP_ID, S.NAME
FROM SHIPS S
WHERE EXISTS(SELECT C.SHIP_ID
             FROM CRUISES C
             WHERE S.SHIP_ID = C.SHIP_ID
             GROUP BY C.SHIP_ID
             HAVING COUNT(C.SHIP_ID) = (SELECT MAX(COUNT(C2.SHIP_ID)) FROM CRUISES C2 GROUP BY C2.SHIP_ID));



-- ENDREGION


-- ------------------------------------------------------------------------
-- 2.1) UNION KLAUSEL
-- ------------------------------------------------------------------------
-- REGION

-- GEBEN SIE FÜR JEDEN PROJEKTTYP DIE ANZAHL DER ZUGEORDNETEN PROJEKTE AN.

-- AUSAGE: PROJECT_TYPE, PROJECT_COUNT

--         @PROJECT_TYPE: REQUEST_FUNDING_PROJECTS  -> REQUEST
--                        RESEARCH_FUNDING_PROJECTS -> RESEARCH
--                        MANAGEMENT_PROJECTS       -> MANAGEMENT

--         @PROJECT_COUNT: ANZAHL DER ZUGEORDNETEN PROJEKTE


-- HINWEIS: BASISTABELLE -> PROJECTS_BT


-- TABLES: PROJECTS_BT, REQUEST_FUNDING_PROJECTS, RESEARCH_FUNDING_PROJECTS, MANAGEMENT_PROJECTS

SELECT 'REQUEST' AS PROJECT_TYPE, COUNT(P.PROJECT_ID) AS PROJECT_COUNT
FROM PROJECTS_BT P
         JOIN REQUEST_FUNDING_PROJECTS RFP ON P.PROJECT_ID = RFP.PROJECT_ID
UNION
SELECT 'RESEARCH' AS PROJECT_TYPE, COUNT(P.PROJECT_ID) AS PROJECT_COUNT
FROM PROJECTS_BT P
         JOIN RESEARCH_FUNDING_PROJECTS RSP ON P.PROJECT_ID = RSP.PROJECT_ID
UNION
SELECT 'MANAGEMENT' AS PROJECT_TYPE, COUNT(P.PROJECT_ID) AS PROJECT_COUNT
FROM PROJECTS_BT P
         JOIN MANAGEMENT_PROJECTS MP ON P.PROJECT_ID = MP.PROJECT_ID;

-- ENDREGION

-- ---------------------------------------------------------------------- -
-- 2.2 UNION KLAUSEL
-- ---------------------------------------------------------------------- -
-- REGION

-- GEBEN SIE FUER JEDES PROJEKT DIE FOLGENDEN SPALTEN AUS: PROJECT_ID, TITLE
-- EVENT_TYPE, EVENT, DATE_OF_EVENT. SORTIEREN SIE DAS ERGEBNIS NACH DER
-- PROJECT_ID UND DEM DATE_OF_EVENT.

-- @EVENT: FUER JEDES PROJEKT SOLLEN ALLE EVENTS (PROJECT_STATE) DER
--         PROJECT_HAS_STATES_JT TABELLE GEMEINSAM MIT DEN EVENTS DER
--         ZUGEORDNETEN SUBPROJEKTE AUSGEGEBEN WERDEN.

-- @EVENT_TYPE: GEGEN SIE 'PROJECT' FUER PROJEKTEVENTS UND
--              'SUBPROJECT' FUER SUBPROJEKTEVENTS AUS

-- @DATE_OF_EVENT: DER ZEITPUNKT AN DEM DAS EVENT EINGETRETEN IST.


-- TABELLEN: PROJECTS, PROJECT_HAS_STATES_JT, SUBPROJECTS,
--           SUBPROJECT_HAS_STATES_JT


SELECT PB.PROJECT_ID,
       PB.TITLE,
       'PROJECT'             AS EVENT_TYPE,
       PHSJ.PROJECT_STATE    AS EVENT,
       PHSJ.STATE_CHANGED_AT AS DATE_OF_EVENT
FROM PROJECTS_BT PB
         JOIN PROJECT_HAS_STATES_JT PHSJ ON PB.PROJECT_ID = PHSJ.PROJECT_ID
UNION
SELECT S.PROJECT_ID,
       BT.TITLE,
       'SUBPROJECT'          AS EVENT_TYPE,
       SHSJ.SUBPROJECT_STATE AS EVENT,
       SHSJ.STATE_CHANGED_AT AS DATE_OF_EVENT
FROM PROJECTS_BT BT
         JOIN SUBPROJECTS S ON BT.PROJECT_ID = S.PROJECT_ID
         JOIN SUBPROJECT_HAS_STATES_JT SHSJ ON S.SUBPROJECT_ID = SHSJ.SUBPROJECT_ID
ORDER BY PROJECT_ID, DATE_OF_EVENT;

SELECT PB.PROJECT_ID, PB.TITLE, 'PROJECT' AS EVENT_TYPE, PROJECT_STATE AS EVENT, STATE_CHANGED_AT AS DATE_OF_EVENT
FROM PROJECT_HAS_STATES_JT
         JOIN PROJECTS_BT PB ON PROJECT_HAS_STATES_JT.PROJECT_ID = PB.PROJECT_ID
UNION
SELECT S.PROJECT_ID, PB.TITLE, 'SUBPROJECT' AS EVENT_TYPE, SUBPROJECT_STATE AS EVENT, STATE_CHANGED_AT AS DATE_OF_EVENT
FROM SUBPROJECT_HAS_STATES_JT
         JOIN SUBPROJECTS S ON S.SUBPROJECT_ID = SUBPROJECT_HAS_STATES_JT.SUBPROJECT_ID
         JOIN PROJECTS_BT PB ON S.PROJECT_ID = PB.PROJECT_ID
ORDER BY PROJECT_ID, DATE_OF_EVENT;

SELECT *
FROM SUBPROJECT_HAS_STATES_JT;
SELECT *
FROM PROJECT_HAS_STATES_JT;
SELECT *
FROM E_PROJECT_STATES;


-- ---------------------------------------------------------------------- -
-- 2.3 BEISPIEL: UNION, EXISTS KLAUSEL
-- ---------------------------------------------------------------------- -
-- REGION

-- GEBEN SIE FUER JEDES PROJEKT DIE FOLGENDEN DATEN AUS: PROJECT_ID, TITLE
-- PROJECT_BEGIN, PROJECT_END, DAY_COUNT

-- HINWEIS: SIE DUERFEN  ZUR LOESUNG DER AUFGABE DIE GROUP BY KLAUSEL NICHT
--          VERWENDEN.

-- @PROJECT_BEGIN: CREATED_AT

-- @PROJECT_END: DAS PROJEKTENDE ENTSPRICHT DEM LETZTEN STATUSWECHSEL
--               DER SUBPROJEKTE DES PROJEKTS. HAT EIN PROJEKT KEINE
--               ZUGEORDNETEN SUBPROJEKTE WIRD DAS DATUM DES LETZTEN
--               STATUSWECHSELS DES PROJEKTS BESTIMMT.

-- TABELLEN: PROJECTS, PROJECT_HAS_STATES_JT, SUBPROJECTS, SUBPROJECTS_HAS_STATES_JT

SELECT PB.PROJECT_ID,
       PB.TITLE,
       PB.CREATED_AT                         AS PROJECT_BEGIN,
       PHSJ.STATE_CHANGED_AT                 AS PROJECT_END,
       PHSJ.STATE_CHANGED_AT - PB.CREATED_AT AS DAY_COUNT
FROM PROJECTS_BT PB
         JOIN PROJECT_HAS_STATES_JT PHSJ ON PB.PROJECT_ID = PHSJ.PROJECT_ID
WHERE NOT EXISTS(SELECT * FROM SUBPROJECTS S WHERE PB.PROJECT_ID = S.PROJECT_ID)
  AND NOT EXISTS(SELECT *
                 FROM PROJECT_HAS_STATES_JT PHSJ2
                 WHERE PB.PROJECT_ID = PHSJ2.PROJECT_ID
                   AND PHSJ.STATE_CHANGED_AT < PHSJ2.STATE_CHANGED_AT)
UNION
SELECT PB.PROJECT_ID,
       PB.TITLE,
       PB.CREATED_AT                         AS PROJECT_BEGIN,
       SHSJ.STATE_CHANGED_AT                 AS PROJECT_END,
       SHSJ.STATE_CHANGED_AT - PB.CREATED_AT AS DAY_COUNT
FROM PROJECTS_BT PB
         JOIN SUBPROJECTS S ON PB.PROJECT_ID = S.PROJECT_ID
         JOIN SUBPROJECT_HAS_STATES_JT SHSJ ON S.SUBPROJECT_ID = SHSJ.SUBPROJECT_ID
WHERE EXISTS(SELECT * FROM SUBPROJECTS S WHERE PB.PROJECT_ID = S.PROJECT_ID)
  AND NOT EXISTS(SELECT *
                 FROM PROJECTS_BT PB2
                          JOIN SUBPROJECTS S2 ON PB2.PROJECT_ID = S2.PROJECT_ID
                 WHERE PB.PROJECT_ID = PB2.PROJECT_ID
                   AND EXISTS(SELECT *
                              FROM SUBPROJECTS S3
                              WHERE S2.SUBPROJECT_ID = S3.SUBPROJECT_ID
                                AND EXISTS(SELECT *
                                           FROM SUBPROJECT_HAS_STATES_JT SHSJ2
                                           WHERE S3.SUBPROJECT_ID = SHSJ2.SUBPROJECT_ID
                                             AND SHSJ.STATE_CHANGED_AT < SHSJ2.STATE_CHANGED_AT)));

SELECT P.PROJECT_ID,
       P.TITLE,
       P.CREATED_AT                        PROJECT_BEGIN,
       PHS.STATE_CHANGED_AT                PROJECT_END,
       PHS.STATE_CHANGED_AT - P.CREATED_AT DAY_COUNT
FROM PROJECTS_BT P
         JOIN PROJECT_HAS_STATES_JT PHS
              ON P.PROJECT_ID = PHS.PROJECT_ID
WHERE NOT EXISTS(SELECT *
                 FROM PROJECT_HAS_STATES_JT PHS2
                 WHERE PHS.PROJECT_ID = PHS2.PROJECT_ID
                   AND PHS.STATE_CHANGED_AT < PHS2.STATE_CHANGED_AT)
  AND P.PROJECT_ID NOT IN (SELECT S.PROJECT_ID FROM SUBPROJECTS S)
UNION
SELECT PB.PROJECT_ID,
       PB.TITLE,
       PB.CREATED_AT                         PROJECT_BEGIN,
       SHSJ.STATE_CHANGED_AT                 PROJECT_END,
       SHSJ.STATE_CHANGED_AT - PB.CREATED_AT DAY_COUNT
FROM PROJECTS_BT PB
         JOIN SUBPROJECTS S ON PB.PROJECT_ID = S.PROJECT_ID
         JOIN SUBPROJECT_HAS_STATES_JT SHSJ ON S.SUBPROJECT_ID = SHSJ.SUBPROJECT_ID
WHERE NOT EXISTS(SELECT *
                 FROM SUBPROJECT_HAS_STATES_JT SHSJ2
                          JOIN SUBPROJECTS S2 ON SHSJ2.SUBPROJECT_ID = S2.SUBPROJECT_ID
                 WHERE PB.PROJECT_ID = S2.PROJECT_ID
                   AND SHSJ.STATE_CHANGED_AT < SHSJ2.STATE_CHANGED_AT);

-- ENDREGION


-- ------------------------------------------------------------------------
-- 2.4) UNION KLAUSEL
-- ------------------------------------------------------------------------
-- REGION

-- GEBEN SIE FÜR JEDEN PROJEKTTYP DAS PROJEKT MIT DER HÖCHSTEN PROJEKT-
-- FÖRDERUNG AN.

-- AUSAGE: PROJECT_TYPE, PROJECT_ID, FUNDING_AMOUNT

--         @PROJECT_TYPE: REQUEST_FUNDING_PROJECTS  -> REQUEST
--                        RESEARCH_FUNDING_PROJECTS -> RESEARCH
--                        MANAGEMENT_PROJECTS       -> MANAGEMENT

--         @PROJECT_ID : DIE PROJECT_ID DES PROJEKTS MIT DER HÖCHSTEN
--                       PROJEKTFÖRDERUNG FÜR DEN ENTSPRECHENDEN
--                       PROJECT_TYPE

--         @FUNDING_AMOUNT: DIE PROJEKTFÖRDERUNG DES PROJEKTS MIT DER
--                          HÖCHSTEN PROJEKTFÖRDERUNG


-- TABLES: PROJECTS_BT, REQUEST_FUNDING_PROJECTS, RESEARCH_FUNDING_PROJECTS, MANAGEMENT_PROJECTS
--         PROJECT_DEBITORS

SELECT 'REQUEST' AS PROJECT_TYPE, PB.PROJECT_ID
FROM PROJECTS_BT PB
         JOIN REQUEST_FUNDING_PROJECTS RFP ON PB.PROJECT_ID = RFP.PROJECT_ID;

SELECT 'REQUEST' AS PROJECT_TYPE, PB.PROJECT_ID, SUM(AMOUNT) AS FUNDING_AMOUNT
FROM PROJECTS_BT PB
         JOIN REQUEST_FUNDING_PROJECTS RFP ON PB.PROJECT_ID = RFP.PROJECT_ID
         JOIN PROJECT_DEBITORS_JT PDJ ON PB.PROJECT_ID = PDJ.PROJECT_ID
GROUP BY PB.PROJECT_ID
HAVING SUM(AMOUNT) = (SELECT MAX(SUM(AMOUNT))
                      FROM PROJECTS_BT PB2
                               JOIN REQUEST_FUNDING_PROJECTS RFP2
                                    ON PB2.PROJECT_ID = RFP2.PROJECT_ID
                               JOIN PROJECT_DEBITORS_JT PDJ2 ON PB2.PROJECT_ID = PDJ2.PROJECT_ID
                      GROUP BY PB2.PROJECT_ID)
UNION
SELECT 'RESEARCH' AS PROJECT_TYPE, PB.PROJECT_ID, SUM(AMOUNT) AS FUNDING_AMOUNT
FROM PROJECTS_BT PB
         JOIN RESEARCH_FUNDING_PROJECTS RFP ON PB.PROJECT_ID = RFP.PROJECT_ID
         JOIN PROJECT_DEBITORS_JT PDJ ON PB.PROJECT_ID = PDJ.PROJECT_ID
GROUP BY PB.PROJECT_ID
HAVING SUM(AMOUNT) = (SELECT MAX(SUM(AMOUNT))
                      FROM PROJECTS_BT PB2
                               JOIN RESEARCH_FUNDING_PROJECTS RFP2
                                    ON PB2.PROJECT_ID = RFP2.PROJECT_ID
                               JOIN PROJECT_DEBITORS_JT PDJ2 ON PB2.PROJECT_ID = PDJ2.PROJECT_ID
                      GROUP BY PB2.PROJECT_ID)
UNION
SELECT 'MANAGEMENT' AS PROJECT_TYPE, PB.PROJECT_ID, SUM(AMOUNT) AS FUNDING_AMOUNT
FROM PROJECTS_BT PB
         JOIN MANAGEMENT_PROJECTS MP ON PB.PROJECT_ID = MP.PROJECT_ID
         JOIN PROJECT_DEBITORS_JT PDJ ON PB.PROJECT_ID = PDJ.PROJECT_ID
GROUP BY PB.PROJECT_ID
HAVING SUM(AMOUNT) = (SELECT MAX(SUM(AMOUNT))
                      FROM PROJECTS_BT PB2
                               JOIN MANAGEMENT_PROJECTS MP2
                                    ON PB2.PROJECT_ID = MP2.PROJECT_ID
                               JOIN PROJECT_DEBITORS_JT PDJ2 ON PB2.PROJECT_ID = PDJ2.PROJECT_ID
                      GROUP BY PB2.PROJECT_ID);

SELECT 'REQUEST' AS PROJECT_TYPE, P.PROJECT_ID, SUM(PDJ.AMOUNT) AS FUNDING_AMOUNT
FROM PROJECTS_BT P
         JOIN REQUEST_FUNDING_PROJECTS RFP ON P.PROJECT_ID = RFP.PROJECT_ID
         JOIN PROJECT_DEBITORS_JT PDJ ON P.PROJECT_ID = PDJ.PROJECT_ID
GROUP BY P.PROJECT_ID
HAVING SUM(PDJ.AMOUNT) =
       (SELECT MAX(SUM(PDJ.AMOUNT))
        FROM PROJECTS_BT P
                 JOIN REQUEST_FUNDING_PROJECTS RFP ON P.PROJECT_ID = RFP.PROJECT_ID
                 JOIN PROJECT_DEBITORS_JT PDJ ON P.PROJECT_ID = PDJ.PROJECT_ID
        GROUP BY P.PROJECT_ID)
UNION
SELECT 'RESEARCH' AS PROJECT_TYPE, P.PROJECT_ID, SUM(J.AMOUNT) AS FUNDING_AMOUNT
FROM PROJECTS_BT P
         JOIN RESEARCH_FUNDING_PROJECTS R ON P.PROJECT_ID = R.PROJECT_ID
         JOIN PROJECT_DEBITORS_JT J ON P.PROJECT_ID = J.PROJECT_ID
GROUP BY P.PROJECT_ID
HAVING SUM(J.AMOUNT) =
       (SELECT MAX(SUM(J.AMOUNT))
        FROM PROJECTS_BT P
                 JOIN RESEARCH_FUNDING_PROJECTS R ON P.PROJECT_ID = R.PROJECT_ID
                 JOIN PROJECT_DEBITORS_JT J ON P.PROJECT_ID = J.PROJECT_ID
        GROUP BY P.PROJECT_ID)
UNION
SELECT 'MANAGEMENT' AS PROJECT_TYPE, P.PROJECT_ID, SUM(PDJ2.AMOUNT) AS FUNDING_AMOUNT
FROM PROJECTS_BT P
         JOIN MANAGEMENT_PROJECTS MP ON P.PROJECT_ID = MP.PROJECT_ID
         JOIN PROJECT_DEBITORS_JT PDJ2 ON P.PROJECT_ID = PDJ2.PROJECT_ID
GROUP BY P.PROJECT_ID
HAVING SUM(PDJ2.AMOUNT) =
       (SELECT MAX(SUM(PDJ2.AMOUNT))
        FROM PROJECTS_BT P
                 JOIN MANAGEMENT_PROJECTS MP ON P.PROJECT_ID = MP.PROJECT_ID
                 JOIN PROJECT_DEBITORS_JT PDJ2 ON P.PROJECT_ID = PDJ2.PROJECT_ID
        GROUP BY P.PROJECT_ID);

-- ENDREGION


-- ------------------------------------------------------------------------
-- 2.5) INTERSECT KLAUSEL
-- ------------------------------------------------------------------------
-- REGION

-- GEBEN SIE ALLE PROJEKTE AUS DIE EINE FORGÄNGERPROJEKT HABEN UND DEREN
-- PROJEKTFÖRDERUNG HÖHER IST ALS 50000

-- AUSAGE: PROJECT_ID, TITLE


-- TABLES: PROJECTS_BT, PROJECT_FORERUNNERS_JT, PROJECT_FORERUNNERS_JT

SELECT PROJECT_ID, TITLE
FROM PROJECTS_BT PB
WHERE EXISTS(SELECT PFJ.PROJECT_ID
             FROM PROJECT_FORERUNNERS_JT PFJ
             WHERE PB.PROJECT_ID = PFJ.PROJECT_ID
             INTERSECT
             SELECT PB.PROJECT_ID
             FROM PROJECT_DEBITORS_JT PDJ
             WHERE PB.PROJECT_ID = PDJ.PROJECT_ID
             GROUP BY PB.PROJECT_ID
             HAVING SUM(PDJ.AMOUNT) > 50000);

SELECT P.PROJECT_ID, P.TITLE
FROM (SELECT PROJECT_ID
      FROM PROJECT_FORERUNNERS_JT
      INTERSECT
      SELECT PD.PROJECT_ID
      FROM PROJECT_DEBITORS_JT PD
      GROUP BY PD.PROJECT_ID
      HAVING SUM(PD.AMOUNT) > 50000) SUB
         JOIN PROJECTS_BT P ON P.PROJECT_ID = SUB.PROJECT_ID;

-- ENDREGION

-- ------------------------------------------------------------------------
-- 2.6) INTERSECT KLAUSEL
-- ------------------------------------------------------------------------
-- REGION

-- FINDEN SIE ALLE GELDGEBER DIE AUSSCHLIESSLICH AUFTRAGSPROJEKTE UMSETZEN UND
-- INSGESAMT EINEN UMSATZ VON MINDESTENS 20000 AN FÖRDERGELDERN INVESTIERT
-- HABEN.

-- AUSGABE: DEBITOR_ID, NAME


-- TABLES: DEBIORS, PROJECT_DEBITORS_JT, REQUEST_FUNDING_PROJECTS

SELECT D.DEBITOR_ID, D.NAME
FROM (SELECT DEBITOR_ID
      FROM REQUEST_FUNDING_PROJECTS RFP
               JOIN PROJECTS_BT PB ON PB.PROJECT_ID = RFP.PROJECT_ID
               JOIN PROJECT_DEBITORS_JT PDJ ON PB.PROJECT_ID = PDJ.PROJECT_ID
      INTERSECT
      SELECT DEBITOR_ID
      FROM PROJECT_DEBITORS_JT
      GROUP BY DEBITOR_ID
      HAVING SUM(AMOUNT) > 20000) SUB
         JOIN DEBITORS D ON SUB.DEBITOR_ID = D.DEBITOR_ID;


SELECT DEBITOR_ID, NAME
FROM DEBITORS D
WHERE EXISTS(SELECT *
             FROM PROJECT_DEBITORS_JT PD
                      JOIN PROJECTS_BT P ON PD.PROJECT_ID = P.PROJECT_ID
                      JOIN REQUEST_FUNDING_PROJECTS RFP ON P.PROJECT_ID = RFP.PROJECT_ID
             WHERE PD.DEBITOR_ID = D.DEBITOR_ID)
INTERSECT
SELECT DEBITOR_ID, NAME
FROM DEBITORS
WHERE DEBITOR_ID IN (SELECT D.DEBITOR_ID
                     FROM DEBITORS D
                              JOIN PROJECT_DEBITORS_JT PD ON D.DEBITOR_ID = PD.DEBITOR_ID
                     GROUP BY D.DEBITOR_ID
                     HAVING SUM(AMOUNT) > 20000);

SELECT D2.DEBITOR_ID, D2.NAME
FROM (SELECT D.DEBITOR_ID
      FROM DEBITORS D
               JOIN PROJECT_DEBITORS_JT PDJ ON D.DEBITOR_ID = PDJ.DEBITOR_ID
               JOIN REQUEST_FUNDING_PROJECTS RFP ON PDJ.PROJECT_ID = RFP.PROJECT_ID
      GROUP BY D.DEBITOR_ID
      HAVING SUM(AMOUNT) > 20000) SELECTION
         JOIN DEBITORS D2 ON D2.DEBITOR_ID = SELECTION.DEBITOR_ID;

-- ENDREGION

-- ------------------------------------------------------------------------
-- 2.7) MINUS KLAUSEL
-- ------------------------------------------------------------------------
-- REGION

-- GEBEN SIE ALLE PROJEKTE DIE WEDER MANAGEMENT- NOCH RESEARCHFUNDINGPROJEKTE
-- SIND.

-- AUSGABE: PROJECT_ID, TITLE

SELECT PROJECT_ID, TITLE
FROM PROJECTS_BT PB
MINUS
(SELECT PB2.PROJECT_ID, PB2.TITLE
 FROM PROJECTS_BT PB2
          JOIN MANAGEMENT_PROJECTS M ON PB2.PROJECT_ID = M.PROJECT_ID
 UNION
 SELECT PB3.PROJECT_ID, PB3.TITLE
 FROM PROJECTS_BT PB3
          JOIN RESEARCH_FUNDING_PROJECTS RFP ON PB3.PROJECT_ID = RFP.PROJECT_ID);


SELECT P.PROJECT_ID, P.TITLE
FROM PROJECTS_BT P
MINUS
(SELECT P.PROJECT_ID, P.TITLE
 FROM RESEARCH_FUNDING_PROJECTS RFP
          JOIN PROJECTS_BT P ON RFP.PROJECT_ID = P.PROJECT_ID
 UNION
 SELECT P.PROJECT_ID, P.TITLE
 FROM MANAGEMENT_PROJECTS M
          JOIN PROJECTS_BT P ON P.PROJECT_ID = M.PROJECT_ID);

-- TABLES: PROJECT_BT, MANAGEMENT_PROJECT, RESEARCH_FUNDING_PROJECTS


-- ENDREGION


-- ---------------------------------------------------------------------- -
-- 1. BEISPIEL: SUBSELECT, WITH KLAUSEL
-- ---------------------------------------------------------------------- -
-- REGION

-- ZUR ERSTELLUNG DER JAEHRLICHEN BILANZ SOLL FUER JEDES PROJEKT EIN
-- REPORT ERSTELLT WERDEN.

-- GEBEN SIE FUER JEDES PROJEKT DIE FOLGENDEN DATEN AUS:
-- AUSGABE: PROJECT_ID, TITLE, PROJECT_TYPE,
--          SUBPROJECT_COUNT, INSTITUTE_COUNT,
--          DEBITOR_COUNT, FUNDING_AMOUNT,
--          PROJECT_COMPLEXITY

-- @PROJECT_TYPE: FUER PROJEKTE SOLL DER TOKEN
--         'REQUEST_FUNDING_PROJECT' FUER RESEARCHFUNDINGPROJEKTE
--         'RESEARCH_FUNDING_PROJECT' FUER REQUESTFUNDINGPROJEKTE
--         'MANAGEMENT_PROJECT' FUER MANAGEMENTPROJEKTE

--          HINWEIS: VERWENDEN SIE ANSONSTEN DEN TOKEN 'DEFAULT_PROJECT'

-- @SUBPROJECT_COUNT: ANZAHL DER SUBPROJEKTE

-- @INSTITUTE_COUNT: ANZAHL DER INSTITUTE DIE AN DER UMSETZUNG DES
--                   PROJEKTS INVOLVIERT SIND

-- @DEBITOR_COUNT: ANZAHL DER GELDGEBER DIE DAS PROJEKT FINANZIELL
--                 UNTERSTUETZEN

-- @FUNDING_AMOUNT: DER GELDBETRAG MIT DEM DAS PROJEKT UNTERSTUETZT WIRD

-- @PROJECT_COMPLEXITY: DIE PROJEKTKOMPLEXITAET BESCHREIBT DIE KOMPLEXITÄT
--                      EINES PROJEKTS. DER WERT IST ALS SUMMER FOLGENDER
--                      POSTEN ZU VERSTEHEN:
--
--  KRITERIUM                                 PUNKTE
--  REQUEST_FUNDING_PROJECT                   10
--  RESEARCH_FUNDING_PROJECT                  5
--  MANAGEMENT_PROJECT                        3
--  THEORETICAL_RESEARCH > 50                 3
--  INSTITUE_COUNT > 3                        2
--  FUNDING_AMOUNT > 50 000                   3

-- SORTIEREN SIE DAS ERGEBNIS NACH DER PROJEKTKOMPLEXITAET ABSTEIGEND

-- TABELLEN: PROJECTS, REQUEST_FUNDING_PROJECTS, RESEARCH_FUNDING_PROJECTS
--           SUBPROJECTS, PROJECT_DEBITORS

WITH PROJECT_DATA AS (SELECT PB2.PROJECT_ID,
                             (CASE
                                  WHEN EXISTS(SELECT *
                                              FROM REQUEST_FUNDING_PROJECTS RFP
                                              WHERE PB2.PROJECT_ID = RFP.PROJECT_ID) THEN 'REQUEST_FUNDING_PROJECT'
                                  WHEN EXISTS(SELECT *
                                              FROM RESEARCH_FUNDING_PROJECTS RSP
                                              WHERE PB2.PROJECT_ID = RSP.PROJECT_ID) THEN 'RESEARCH_FUNDING_PROJECT'
                                  WHEN EXISTS(SELECT * FROM MANAGEMENT_PROJECTS MP WHERE PB2.PROJECT_ID = MP.PROJECT_ID)
                                      THEN 'MANAGEMENT_PROJECT'
                                  ELSE 'DEFAULT_PROJECT'
                                 END) AS PROJECT_TYPE
                      FROM PROJECTS_BT PB2),
     SUBPROJECT_COUNT AS (SELECT PROJECT_ID, COUNT(DISTINCT SUBPROJECT_ID) SUBPROJECT_COUNT
                          FROM SUBPROJECTS
                          GROUP BY PROJECT_ID),
     INSTITUTE_COUNT AS (SELECT PROJECT_ID, COUNT(DISTINCT INSTITUTE_ID) INSTITUTE_COUNT
                         FROM SUBPROJECTS S2
                                  JOIN FACILITIES_ST FS2 ON S2.INSTITUTE_ID = FS2.FACILITY_ID
                         GROUP BY PROJECT_ID),
     DEBITOR_COUNT AS (SELECT PROJECT_ID, COUNT(DISTINCT DEBITOR_ID) DEBITOR_COUNT
                       FROM PROJECT_DEBITORS_JT S2
                       GROUP BY PROJECT_ID),
     FUNDING_AMOUNT AS (SELECT PROJECT_ID, SUM(AMOUNT) FUNDING_AMOUNT
                        FROM PROJECT_DEBITORS_JT S2
                        GROUP BY PROJECT_ID),
     COMPLEXITY1 AS (SELECT PB2.PROJECT_ID,
                            (CASE
                                 WHEN EXISTS(SELECT *
                                             FROM REQUEST_FUNDING_PROJECTS RFP
                                             WHERE PB2.PROJECT_ID = RFP.PROJECT_ID) THEN 10
                                 WHEN EXISTS(SELECT *
                                             FROM RESEARCH_FUNDING_PROJECTS RSP
                                             WHERE PB2.PROJECT_ID = RSP.PROJECT_ID) THEN 5
                                 WHEN EXISTS(SELECT * FROM MANAGEMENT_PROJECTS MP WHERE PB2.PROJECT_ID = MP.PROJECT_ID)
                                     THEN 3
                                 ELSE 0
                                END) AS COMPLEXITY1
                     FROM PROJECTS_BT PB2),
     COMPLEXITY2 AS (SELECT PROJECT_ID, SUM(COMPLEXITY2) COMPLEXITY2
                     FROM (SELECT PROJECT_ID,
                                  CASE WHEN THEORETICAL_RESEARCH > 50 THEN 3 ELSE 0 END AS COMPLEXITY2
                           FROM SUBPROJECTS) SUB
                     GROUP BY SUB.PROJECT_ID),
     COMPLEXITY3 AS (SELECT PROJECT_ID, CASE WHEN COUNT(DISTINCT INSTITUTE_ID) > 3 THEN 2 ELSE 0 END COMPLEXITY3
                     FROM SUBPROJECTS S2
                              JOIN FACILITIES_ST FS2 ON S2.INSTITUTE_ID = FS2.FACILITY_ID
                     GROUP BY PROJECT_ID),
     COMPLEXITY4 AS (SELECT PROJECT_ID, CASE WHEN SUM(AMOUNT) > 50000 THEN 3 ELSE 0 END COMPLEXITY4
                     FROM PROJECT_DEBITORS_JT S2
                     GROUP BY PROJECT_ID)
SELECT PB.PROJECT_ID,
       PB.TITLE,
       PD.PROJECT_TYPE                  AS PROJECT_TYPE,
       COALESCE(SC.SUBPROJECT_COUNT, 0) AS SUBPROJECT_COUNT,
       COALESCE(IC.INSTITUTE_COUNT, 0)  AS INSTITUTE_COUNT,
       COALESCE(DC.DEBITOR_COUNT, 0)    AS DEBITOR_COUNT,
       COALESCE(FA.FUNDING_AMOUNT, 0)   AS FUNDING_AMOUNT,
       COALESCE(C1.COMPLEXITY1, 0) + COALESCE(C2.COMPLEXITY2, 0) + COALESCE(C3.COMPLEXITY3, 0) +
       COALESCE(C4.COMPLEXITY4, 0)      AS PROJECT_COMPLEXITY
FROM PROJECTS_BT PB
         LEFT JOIN PROJECT_DATA PD ON PB.PROJECT_ID = PD.PROJECT_ID
         LEFT JOIN SUBPROJECT_COUNT SC ON PB.PROJECT_ID = SC.PROJECT_ID
         LEFT JOIN INSTITUTE_COUNT IC ON PB.PROJECT_ID = IC.PROJECT_ID
         LEFT JOIN DEBITOR_COUNT DC ON PB.PROJECT_ID = DC.PROJECT_ID
         LEFT JOIN FUNDING_AMOUNT FA ON PB.PROJECT_ID = FA.PROJECT_ID

         LEFT JOIN COMPLEXITY1 C1 ON PB.PROJECT_ID = C1.PROJECT_ID
         LEFT JOIN COMPLEXITY2 C2 ON PB.PROJECT_ID = C2.PROJECT_ID
         LEFT JOIN COMPLEXITY3 C3 ON PB.PROJECT_ID = C3.PROJECT_ID
         LEFT JOIN COMPLEXITY4 C4 ON PB.PROJECT_ID = C4.PROJECT_ID

ORDER BY PROJECT_COMPLEXITY DESC, PROJECT_ID ASC;



WITH PROJECT_DATA AS (SELECT P.PROJECT_ID,
                             CASE
                                 WHEN RFP.IS_SMALL_PROJECT IS NOT NULL THEN 'REQEUST_FUNDING_PROJECT'
                                 WHEN R.IS_EU_SPONSORED IS NOT NULL THEN 'RESEARCH_FUNDING_PROJECT'
                                 WHEN MP.MANAGEMENT_DUTY IS NOT NULL THEN 'MANAGEMENT_PROJECT'
                                 ELSE 'DEFAULT_PROJECT' END AS PROJECT_TYPE,
                             CASE
                                 WHEN RFP.IS_SMALL_PROJECT IS NOT NULL THEN 10
                                 WHEN R.IS_EU_SPONSORED IS NOT NULL THEN 5
                                 ELSE 3 END                 AS PROJECT_RATING
                      FROM PROJECTS_BT P
                               LEFT JOIN REQUEST_FUNDING_PROJECTS RFP ON P.PROJECT_ID = RFP.PROJECT_ID
                               LEFT JOIN RESEARCH_FUNDING_PROJECTS R ON P.PROJECT_ID = R.PROJECT_ID
                               LEFT JOIN MANAGEMENT_PROJECTS MP ON P.PROJECT_ID = MP.PROJECT_ID),
     SUBPROJECTDATA_BY_PROJECT AS (SELECT S.PROJECT_ID,
                                          COUNT(S.SUBPROJECT_ID)                                        SUBPROJECT_COUNT,
                                          COUNT(UNIQUE INSTITUTE_ID)                                    INSTITUTE_COUNT,
                                          CASE WHEN COUNT(UNIQUE INSTITUTE_ID) > 3 THEN 2 ELSE 0 END AS PROJECT_RATING
                                   FROM SUBPROJECTS S
                                   GROUP BY S.PROJECT_ID),
     FUNDING_DATA_BY_PROJECT AS (SELECT COUNT(PD.DEBITOR_ID)                                  DEBITOR_COUNT,
                                        SUM(PD.AMOUNT)                                        FUNDING_AMOUNT,
                                        CASE WHEN SUM(PD.AMOUNT) > 50000 THEN 3 ELSE 0 END AS PROJECT_RATING,
                                        PD.PROJECT_ID
                                 FROM PROJECT_DEBITORS_JT PD
                                 GROUP BY PD.PROJECT_ID),
     RESEARCH_BY_PROJECT AS (SELECT SUB.PROJECT_ID, SUM(PROJECT_RATING) PROJECT_RATING
                             FROM (SELECT S.PROJECT_ID,
                                          CASE
                                              WHEN S.THEORETICAL_RESEARCH > 50 THEN 3
                                              ELSE 0 END AS PROJECT_RATING
                                   FROM SUBPROJECTS S) SUB
                             GROUP BY SUB.PROJECT_ID)
SELECT DISTINCT P.PROJECT_ID,
                P.TITLE,
                COALESCE(PT.PROJECT_TYPE, 'DEFAULT_PROJECT') AS PROJECT_TYPE,
                COALESCE(SBP.SUBPROJECT_COUNT, 0)            AS SUBPROJECT_COUNT,
                COALESCE(SBP.INSTITUTE_COUNT, 0)             AS INSTITUTE_COUNT,
                COALESCE(FDP.DEBITOR_COUNT, 0)               AS DEBITOR_COUNT,
                COALESCE(FDP.FUNDING_AMOUNT, 0)              AS FUNDING_AMOUNT,
                COALESCE(PT.PROJECT_RATING, 0) + COALESCE(SBP.PROJECT_RATING, 0) + COALESCE(FDP.PROJECT_RATING, 0) +
                COALESCE(FRP.PROJECT_RATING, 0)              AS PROJECT_COMPLEXITY
FROM PROJECTS_BT P
         LEFT JOIN PROJECT_DATA PT ON PT.PROJECT_ID = P.PROJECT_ID
         LEFT JOIN SUBPROJECTDATA_BY_PROJECT SBP ON SBP.PROJECT_ID = P.PROJECT_ID
         LEFT JOIN FUNDING_DATA_BY_PROJECT FDP ON FDP.PROJECT_ID = P.PROJECT_ID
         LEFT JOIN RESEARCH_BY_PROJECT FRP ON FRP.PROJECT_ID = P.PROJECT_ID
ORDER BY PROJECT_COMPLEXITY DESC, PROJECT_ID ASC;

-- ENDREGION


-- ---------------------------------------------------------------------- -
-- 2. BEISPIEL: SUBSELECT, EXISTS KLAUSEL
-- ---------------------------------------------------------------------- -
-- REGION

-- FINDEN SIE ALLE PROJEKTE DENEN ZUMINDESTENS 1 SUBPROJEKT ZUGEORDNET IST.
-- GEBEN SIE FÜR PROJEKT DATENSÄTZE FOLGENDE WERTE AUS: PROJECT_ID, TITLE


-- TABLE: PROJECTS_BT, SUBPROJECTS

SELECT PROJECT_ID, TITLE
FROM PROJECTS_BT
WHERE EXISTS(SELECT * FROM SUBPROJECTS WHERE PROJECTS_BT.PROJECT_ID = SUBPROJECTS.PROJECT_ID);


SELECT *
FROM PROJECTS_BT P
WHERE EXISTS(SELECT * FROM SUBPROJECTS S WHERE S.PROJECT_ID = P.PROJECT_ID);

-- ENDREGION

-- ---------------------------------------------------------------------- -
-- 3. BEISPIEL: SUBSELECT, EXISTS KLAUSEL
-- ---------------------------------------------------------------------- -
-- REGION

-- FINDEN SIE ALLE GELDGEBER DIE ZUMINDESTENS EIN PROJEKT FINANZIELL UNTER-
-- STÜTZEN.

-- GEBEN SIE FÜR DEBITOR DATENSÄTZE FOLGENDE WERTE AUS: DEBITOR_ID, NAME


-- TABLE: DEBITORS, PROJECT_DEBITORS_JT

SELECT DEBITOR_ID, NAME
FROM DEBITORS D
WHERE EXISTS(SELECT * FROM PROJECT_DEBITORS_JT PDJ WHERE D.DEBITOR_ID = PDJ.DEBITOR_ID);

SELECT D.DEBITOR_ID, D.NAME
FROM DEBITORS D
WHERE EXISTS(SELECT * FROM PROJECT_DEBITORS_JT PD WHERE PD.DEBITOR_ID = D.DEBITOR_ID);

-- ENDREGION

-- ---------------------------------------------------------------------- -
-- 4. BEISPIEL: SUBSELECT, EXISTS KLAUSEL
-- ---------------------------------------------------------------------- -
-- REGION

-- GEBEN SIE ALLE GESETZLICHEN PARAGRAPHEN (E_LEGAL_FOUNDATIONS) AN, DENEN
-- ZUMINDESTENS 1 PROJEKT ZUGEORDNET IST.

-- GEBEN SIE FÜR E_LEGAL_FOUNDATIONS DATENSÄTZE FOLGENDE SPALTEN AUS: LABEL


-- TABLES: E_LEGAL_FOUNDATIONS, PROJECTS_BT

SELECT LABEL
FROM E_LEGAL_FOUNDATIONS ELF
WHERE EXISTS(SELECT * FROM PROJECTS_BT PB WHERE ELF.LABEL = PB.LEGAL_FOUNDATION);


SELECT FL.LABEL
FROM E_LEGAL_FOUNDATIONS FL
WHERE EXISTS(SELECT * FROM PROJECTS_BT P WHERE P.LEGAL_FOUNDATION = FL.LABEL);

-- ENDREGION

-- ---------------------------------------------------------------------- -
-- 5. BEISPIEL: SUBSELECT, EXISTS KLAUSEL
-- ---------------------------------------------------------------------- -
-- REGION

-- FINDEN SIE ALLE PROJEKTE DIE KEINE FINANZIELLE UNTERSTÜTZUNG HABEN.
-- GEBEN SIE FOLGENDE SPALTEN AUS: PROJECT_ID, TITLE


-- TABLE: PROJECTS_BT, PROJECT_DEBITORS_JT

SELECT PROJECT_ID, TITLE
FROM PROJECTS_BT PB
WHERE NOT EXISTS(SELECT * FROM PROJECT_DEBITORS_JT WHERE PB.PROJECT_ID = PROJECT_DEBITORS_JT.PROJECT_ID)

SELECT *
FROM PROJECTS_BT P
WHERE NOT EXISTS(SELECT * FROM PROJECT_DEBITORS_JT PD WHERE PD.PROJECT_ID = P.PROJECT_ID);

-- ENDREGION

-- ---------------------------------------------------------------------- -
-- 6. BEISPIEL: SUBSELECT, EXISTS KLAUSEL
-- ---------------------------------------------------------------------- -
-- REGION

-- FINDEN SIE ALLE INSTITUE (FACILITIES_ST.FACILITY_TYPE -> INSTITUTE) DIE
-- KEINE SUBPROJEKTE UMGESETZT HABEN.

-- GEBEN SIE FÜR INSTITUTE FOLGENDE SPALTEN AUS:


-- TABLE: FACILITIES_ST, SUBPROJECTS

SELECT FACILITY_ID, FACILITY_TYPE
FROM FACILITIES_ST F
WHERE NOT EXISTS(SELECT * FROM SUBPROJECTS S WHERE F.FACILITY_ID = S.INSTITUTE_ID)
  AND FACILITY_TYPE = 'INSTITUTE';


SELECT *
FROM FACILITIES_ST I
WHERE I.FACILITY_TYPE = 'INSTITUTE'
  AND NOT EXISTS(SELECT * FROM SUBPROJECTS S WHERE S.INSTITUTE_ID = I.FACILITY_ID);

-- ENDREGION

-- ---------------------------------------------------------------------- -
-- 7. BEISPIEL: SUBSELECT, EXISTS KLAUSEL
-- ---------------------------------------------------------------------- -
-- REGION

-- FINDEN SIE ALLE PROJEKTE DIE NICHT VORGÄNGEPROJEKTE ANDERER PROJEKTE SIND.
-- GEBEN SIE FÜR PROJEKTE FOLGENDE SPALTEN AUS: PROJECT_ID, TITLE


-- TABLE: PROJECTS_BT, PROJECT_FORERUNNERS_JT

SELECT PROJECT_ID, TITLE
FROM PROJECTS_BT
WHERE NOT EXISTS(SELECT * FROM PROJECT_FORERUNNERS_JT WHERE PROJECTS_BT.PROJECT_ID = PARENT_ID);


SELECT *
FROM PROJECTS_BT P
WHERE NOT EXISTS(SELECT * FROM PROJECT_FORERUNNERS_JT PF WHERE PF.PARENT_ID = P.PROJECT_ID);

-- ENDREGION

-- ---------------------------------------------------------------------- -
-- 8. BEISPIEL: JOIN, EXISTS KLAUSEL
-- ---------------------------------------------------------------------- -
-- REGION

-- WIR WÜRDEN GERNE UNSERER DEBITOREN ANSCHREIBEN, OB SIE NICHT VIELLEICHT AUCH ANDERE PROJEKTE UNTERSTÜTZEN WOLLEN.
-- DAZU BRAUCHEN WIR EINE LISTE VON DEBITOREN UND PROJEKTE DIE SIE MOMENTAN NOCH NICHT UNTERSTÜTZEN.

-- AUSGABE: PROJECT_ID, TITLE, DEBITOR_ID, (DEBITOR) NAME

-- TABLE: PROJECTS_BT, DEBITORS, PROJECT_DEBITORS_JT

SELECT DEBITOR_ID, NAME, PROJECT_ID, TITLE
FROM DEBITORS D
         CROSS JOIN PROJECTS_BT PB
WHERE NOT EXISTS(SELECT *
                 FROM PROJECT_DEBITORS_JT PDJ
                 WHERE D.DEBITOR_ID = PDJ.DEBITOR_ID
                   AND PB.PROJECT_ID = PDJ.PROJECT_ID)
ORDER BY DEBITOR_ID ASC, PROJECT_ID ASC;

SELECT P.PROJECT_ID, P.TITLE, D.NAME
FROM PROJECTS_BT P
         CROSS JOIN DEBITORS D
WHERE NOT EXISTS(SELECT *
                 FROM PROJECT_DEBITORS_JT PD
                 WHERE PD.PROJECT_ID = P.PROJECT_ID
                   AND PD.DEBITOR_ID = D.DEBITOR_ID)
ORDER BY DEBITOR_ID ASC, PROJECT_ID ASC;

-- ---------------------------------------------------------------------- -
-- 1. BEISPIEL: SUBSELECT, WITH KLAUSEL
-- ---------------------------------------------------------------------- -
-- REGION

-- ES WIRD EINE AUFSTELLUNG DER LEGAL FOUNDATIONS BENÖTIGT.

-- GEBEN SIE FUER JEDES PROJEKT DIE FOLGENDEN DATEN AUS:
-- AUSGABE: LEGAL FOUNDATION LABEL, LEGAL FOUNDATION DESCRIPTION,
--          AVG_APPLIED_RESEARCH,COUNT_FACULTIES, SPENT_BUDGET,
--          PERCENT_OF_TOTAL_BUDGET

-- @AVG_APPLIED_RESEARCH: DURCHSCHNITTLICHER APPLIED RESEACH ANTEIL PRO LEGAL FOUNDATION

-- @COUNT_FACULTIES: ANZAHL AN EINDEUTIG INVOLVIERTEN FACULTÄTEN PRO LEGAL FOUNDATION

-- @SPENT_BUDGET: BUDGET DAS FÜR DIESE LEGAL FOUNDATION INVESTIERT WURDE

-- @PERCENT_OF_TOTAL_BUDGET: % ANTEIL AUS DEM GESAMT BUDGET

-- SORTIEREN SIE DAS ERGEBNIS NACH DER DEM PERCENT_OF_TOTAL_BUDGET ABSTEIGEND

WITH LEGAL_FOUNDATION_DATA AS (SELECT PROJECT_ID, LABEL, ELF.DESCRIPTION
                               FROM PROJECTS_BT PB2
                                        JOIN E_LEGAL_FOUNDATIONS ELF ON PB2.LEGAL_FOUNDATION = ELF.LABEL),
     AVG_APPLIED_RESEARCH AS (SELECT LEGAL_FOUNDATION, AVG(APPLIED_RESEARCH) AS AVG_APPLIED_RESEARCH
                              FROM PROJECTS_BT PB3
                                       LEFT JOIN SUBPROJECTS ON PB3.PROJECT_ID = SUBPROJECTS.PROJECT_ID
                              GROUP BY PB3.LEGAL_FOUNDATION),
     COUNT_FACULTIES AS (SELECT LEGAL_FOUNDATION, COUNT(DISTINCT FACULTY_ID) AS COUNT_FACULTIES
                         FROM PROJECTS_BT PB4
                                  LEFT JOIN SUBPROJECTS ON PB4.PROJECT_ID = SUBPROJECTS.PROJECT_ID
                                  LEFT JOIN FACILITIES_ST ON SUBPROJECTS.INSTITUTE_ID = FACILITIES_ST.FACILITY_ID
                         GROUP BY PB4.LEGAL_FOUNDATION),
     SPENT_BUDGET AS (SELECT LEGAL_FOUNDATION, SUM(AMOUNT) AS SPENT_BUDGET
                      FROM PROJECTS_BT PB5
                               LEFT JOIN PROJECT_DEBITORS_JT PDJ ON PB5.PROJECT_ID = PDJ.PROJECT_ID
                      GROUP BY PB5.LEGAL_FOUNDATION),
     TOTAL_BUDGET AS (SELECT SUM(AMOUNT) TOTAL_BUDGET
                      FROM PROJECT_DEBITORS_JT)
SELECT DISTINCT LFD.LABEL,
                LFD.DESCRIPTION,
                COALESCE(ROUND(AAR.AVG_APPLIED_RESEARCH, 2), 0)                AS AVG_APPLIED_RESEARCH,
                COALESCE(CF.COUNT_FACULTIES, 0)                                AS COUNT_FACULTIES,
                COALESCE(SB.SPENT_BUDGET, 0)                                   AS SPENT_BUDGET,
                COALESCE(ROUND(SB.SPENT_BUDGET / TB.TOTAL_BUDGET * 100, 2), 0) AS PERCENT_OF_TOTAL_BUDGET
FROM PROJECTS_BT PB

         LEFT JOIN LEGAL_FOUNDATION_DATA LFD
                   ON PB.PROJECT_ID = LFD.PROJECT_ID
         LEFT JOIN AVG_APPLIED_RESEARCH AAR ON AAR.LEGAL_FOUNDATION = PB.LEGAL_FOUNDATION
         LEFT JOIN COUNT_FACULTIES CF
                   ON CF.LEGAL_FOUNDATION = PB.LEGAL_FOUNDATION
         LEFT JOIN SPENT_BUDGET SB
                   ON SB.LEGAL_FOUNDATION = PB.LEGAL_FOUNDATION
         CROSS JOIN TOTAL_BUDGET TB
ORDER BY PERCENT_OF_TOTAL_BUDGET DESC;


-- ENDREGION

-- ---------------------------------------------------------------------- -
-- 2. BEISPIEL: SUBSELECT, WITH
-- ---------------------------------------------------------------------- -
-- REGION
-- ERWEITERN SIE BEISPIEL 1 UM FOLGENDE BEDINGUNG.
-- NUR ALLE PROJEKTE BERÜCKSICHTIGEN, WELCHE MEHR ALS 1 SUBPROJEKT HABEN.

WITH LEGAL_FOUNDATION_DATA AS (SELECT PROJECT_ID, LABEL, ELF.DESCRIPTION
                               FROM PROJECTS_BT PB2
                                        JOIN E_LEGAL_FOUNDATIONS ELF ON PB2.LEGAL_FOUNDATION = ELF.LABEL

                               WHERE EXISTS(SELECT PB2.PROJECT_ID
                                            FROM SUBPROJECTS S2
                                            WHERE PB2.PROJECT_ID = S2.PROJECT_ID
                                            GROUP BY PB2.PROJECT_ID
                                            HAVING COUNT(SUBPROJECT_ID) > 1)),
     AVG_APPLIED_RESEARCH AS (SELECT LEGAL_FOUNDATION, AVG(APPLIED_RESEARCH) AS AVG_APPLIED_RESEARCH
                              FROM PROJECTS_BT PB3
                                       LEFT JOIN SUBPROJECTS ON PB3.PROJECT_ID = SUBPROJECTS.PROJECT_ID
                              WHERE EXISTS(SELECT PB3.PROJECT_ID
                                           FROM SUBPROJECTS S3
                                           WHERE PB3.PROJECT_ID = S3.PROJECT_ID
                                           GROUP BY PB3.PROJECT_ID
                                           HAVING COUNT(SUBPROJECT_ID) > 1)
                              GROUP BY PB3.LEGAL_FOUNDATION),
     COUNT_FACULTIES AS (SELECT LEGAL_FOUNDATION, COUNT(DISTINCT FACULTY_ID) AS COUNT_FACULTIES
                         FROM PROJECTS_BT PB4
                                  LEFT JOIN SUBPROJECTS ON PB4.PROJECT_ID = SUBPROJECTS.PROJECT_ID
                                  LEFT JOIN FACILITIES_ST ON SUBPROJECTS.INSTITUTE_ID = FACILITIES_ST.FACILITY_ID
                         WHERE EXISTS(SELECT PB4.PROJECT_ID
                                      FROM SUBPROJECTS S4
                                      WHERE PB4.PROJECT_ID = S4.PROJECT_ID
                                      GROUP BY PB4.PROJECT_ID
                                      HAVING COUNT(SUBPROJECT_ID) > 1)
                         GROUP BY PB4.LEGAL_FOUNDATION),
     SPENT_BUDGET AS (SELECT LEGAL_FOUNDATION, SUM(AMOUNT) AS SPENT_BUDGET
                      FROM PROJECTS_BT PB5
                               LEFT JOIN PROJECT_DEBITORS_JT PDJ ON PB5.PROJECT_ID = PDJ.PROJECT_ID
                      WHERE EXISTS(SELECT PB5.PROJECT_ID
                                   FROM SUBPROJECTS S5
                                   WHERE PB5.PROJECT_ID = S5.PROJECT_ID
                                   GROUP BY PB5.PROJECT_ID
                                   HAVING COUNT(SUBPROJECT_ID) > 1)
                      GROUP BY PB5.LEGAL_FOUNDATION),
     TOTAL_BUDGET AS (SELECT SUM(AMOUNT) TOTAL_BUDGET
                      FROM PROJECTS_BT PB6
                               JOIN PROJECT_DEBITORS_JT PDJ2 ON PB6.PROJECT_ID = PDJ2.PROJECT_ID
                      WHERE EXISTS(SELECT PB6.PROJECT_ID
                                   FROM SUBPROJECTS S6
                                   WHERE PB6.PROJECT_ID = S6.PROJECT_ID
                                   GROUP BY PB6.PROJECT_ID
                                   HAVING COUNT(SUBPROJECT_ID) > 1))
SELECT DISTINCT LFD.LABEL,
                LFD.DESCRIPTION,
                COALESCE(ROUND(AAR.AVG_APPLIED_RESEARCH, 2), 0)                AS AVG_APPLIED_RESEARCH,
                COALESCE(CF.COUNT_FACULTIES, 0)                                AS COUNT_FACULTIES,
                COALESCE(SB.SPENT_BUDGET, 0)                                   AS SPENT_BUDGET,
                COALESCE(ROUND(SB.SPENT_BUDGET / TB.TOTAL_BUDGET * 100, 2), 0) AS PERCENT_OF_TOTAL_BUDGET
FROM PROJECTS_BT PB

         LEFT JOIN LEGAL_FOUNDATION_DATA LFD
                   ON PB.PROJECT_ID = LFD.PROJECT_ID
         LEFT JOIN AVG_APPLIED_RESEARCH AAR ON AAR.LEGAL_FOUNDATION = PB.LEGAL_FOUNDATION
         LEFT JOIN COUNT_FACULTIES CF
                   ON CF.LEGAL_FOUNDATION = PB.LEGAL_FOUNDATION
         LEFT JOIN SPENT_BUDGET SB
                   ON SB.LEGAL_FOUNDATION = PB.LEGAL_FOUNDATION
         CROSS JOIN TOTAL_BUDGET TB
WHERE EXISTS(SELECT PB.PROJECT_ID
             FROM SUBPROJECTS S
             WHERE PB.PROJECT_ID = S.PROJECT_ID
             GROUP BY PB.PROJECT_ID
             HAVING COUNT(SUBPROJECT_ID) > 1)
ORDER BY PERCENT_OF_TOTAL_BUDGET DESC;

-- ENDREGION

-- ---------------------------------------------------------------------- -
-- 3. BEISPIEL: SUBSELECT, EXISTS KLAUSEL
-- ---------------------------------------------------------------------- -
-- REGION

-- FINDEN SIE ALLE PROJEKTE DENEN ZUMINDESTENS 1 SUBPROJEKT ZUGEORDNET IST.
-- GEBEN SIE FÜR PROJEKT DATENSÄTZE FOLGENDE WERTE AUS: PROJECT_ID, TITLE


-- TABLE: PROJECTS_BT, SUBPROJECTS

SELECT *
FROM PROJECTS_BT PB
WHERE EXISTS(SELECT S.PROJECT_ID
             FROM SUBPROJECTS S
             WHERE PB.PROJECT_ID = S.PROJECT_ID
             GROUP BY S.PROJECT_ID
             HAVING COUNT(SUBPROJECT_ID) > 1);

-- ENDREGION

-- ---------------------------------------------------------------------- -
-- 4. BEISPIEL: SUBSELECT, EXISTS KLAUSEL
-- ---------------------------------------------------------------------- -
-- REGION

-- FINDEN SIE ALLE GELDGEBER DIE ZUMINDESTENS EIN PROJEKT FINANZIELL UNTER-
-- STÜTZEN UND IM NAMEN FA HABEN.

-- GEBEN SIE FÜR DEBITOR DATENSÄTZE FOLGENDE WERTE AUS: DEBITOR_ID, NAME


-- TABLE: DEBITORS, PROJECT_DEBITORS_JT

SELECT *
FROM DEBITORS D
WHERE D.NAME LIKE '%FA%'
  AND EXISTS(SELECT * FROM PROJECT_DEBITORS_JT PDJ WHERE D.DEBITOR_ID = PDJ.PROJECT_ID)

-- ENDREGION

-- ---------------------------------------------------------------------- -
-- 5. BEISPIEL: SUBSELECT, EXISTS KLAUSEL
-- ---------------------------------------------------------------------- -
-- REGION

-- GEBEN SIE ALLE GESETZLICHEN PARAGRAPHEN (E_LEGAL_FOUNDATIONS) AN, DENEN
-- ZUMINDESTENS 1 PROJEKT ZUGEORDNET IST.

-- GEBEN SIE FÜR E_LEGAL_FOUNDATIONS DATENSÄTZE FOLGENDE SPALTEN AUS: LABEL


-- TABLES: E_LEGAL_FOUNDATIONS, PROJECTS_BT

SELECT LABEL
FROM E_LEGAL_FOUNDATIONS ELF
WHERE EXISTS(SELECT * FROM PROJECTS_BT PB WHERE PB.LEGAL_FOUNDATION = ELF.LABEL);

-- ENDREGION

-- ---------------------------------------------------------------------- -
-- 6. BEISPIEL: SUBSELECT, EXISTS KLAUSEL
-- ---------------------------------------------------------------------- -
-- REGION

-- FINDEN SIE ALLE PROJEKTE DIE KEINE FINANZIELLE UNTERSTÜTZUNG HABEN.
-- GEBEN SIE FOLGENDE SPALTEN AUS: PROJECT_ID, TITLE


-- TABLE: PROJECTS_BT, PROJECT_DEBITORS_JT

SELECT PROJECT_ID, TITLE
FROM PROJECTS_BT PB
WHERE NOT EXISTS(SELECT * FROM PROJECT_DEBITORS_JT PDJ WHERE PB.PROJECT_ID = PDJ.PROJECT_ID);

-- ENDREGION

-- ---------------------------------------------------------------------- -
-- 7. BEISPIEL: SUBSELECT, EXISTS KLAUSEL
-- ---------------------------------------------------------------------- -
-- REGION

-- FINDEN SIE ALLE INSTITUE (FACILITIES_ST.FACILITY_TYPE -> INSTITUTE) DIE
-- KEINE SUBPROJEKTE UMGESETZT HABEN.

-- GEBEN SIE FÜR INSTITUTE FOLGENDE SPALTEN AUS:


-- TABLE: FACILITIES_ST, SUBPROJECTS

SELECT FACILITY_ID, FACILITY_TITLE
FROM FACILITIES_ST I
WHERE I.FACILITY_TYPE = 'INSTITUTE'
  AND NOT EXISTS(SELECT * FROM SUBPROJECTS S WHERE S.INSTITUTE_ID = I.FACILITY_ID)
ORDER BY FACILITY_ID;


-- ENDREGION

-- ---------------------------------------------------------------------- -
-- 8. BEISPIEL: SUBSELECT, EXISTS KLAUSEL
-- ---------------------------------------------------------------------- -
-- REGION

-- FINDEN SIE ALLE PROJEKTE DIE NICHT VORGÄNGEPROJEKTE ANDERER PROJEKTE SIND.
-- GEBEN SIE FÜR PROJEKTE FOLGENDE SPALTEN AUS: PROJECT_ID, TITLE


-- TABLE: PROJECTS_BT, PROJECT_FORERUNNERS_JT

SELECT *
FROM PROJECTS_BT PB
WHERE NOT EXISTS(SELECT * FROM PROJECT_FORERUNNERS_JT PFJ WHERE PB.PROJECT_ID = PFJ.PARENT_ID)

-- ENDREGION


-- ---------------------------------------------------------------------- -
-- 9. BEISPIEL: SUBSELECT
-- ---------------------------------------------------------------------- -
-- REGION

-- WIR WÜRDEN GERNE UNSERE MARKETING ABTEILUNG EINE ABFRAGE ERSTELLEN.
-- WIR WOLLEN ALLE DEBITOREN ZU DEN NICHT VON IHNEN UNTERSTÜTZTEN PROJEKTEN ANSCHREIBEN.
-- DAZU BENÖTIGEN WIR EINE LISTE MIT DEN DEBITOREN UND ALLEN PROJEKTEN DIE SIE MOMENTAN NICHT UNTERSTÜTZEN.

-- SPALTEN: PROJECT_ID,TITLE,DEBITOR_ID,NAME

-- TABLE: PROJECTS_BT, PROJECT_DEBITORS_JT, DEBITORS

SELECT PROJECT_ID, TITLE, DEBITOR_ID, NAME
FROM DEBITORS D
         CROSS JOIN PROJECTS_BT PB
WHERE NOT EXISTS(SELECT *
                 FROM PROJECT_DEBITORS_JT PDJ
                 WHERE PB.PROJECT_ID = PDJ.PROJECT_ID
                   AND D.DEBITOR_ID = PDJ.DEBITOR_ID);

-- ENDREGION

-- ---------------------------------------------------------------------- -
-- 10. BEISPIEL: SUBSELECT
-- ---------------------------------------------------------------------- -

-- FINDEN SIE DAS SUBPROJEKT MIT DEM HOECHSTEN WERT FUER DEN FOCUS_RESEARCH.
-- GEBEN SIE FUER DAS SUBPROJEKT DIE FOLGENDEN SPALTEN AUS:
-- DESCRIPTION, PROJECT_ID, FOCUS_RESEARCH

-- HINWEIS: BEACHTEN SIE DASS ES MEHRERE SUBPROJEKTE MIT EINEM MAXIMALEN
--          FOCUS_RESEARCH WERT GEBEN KANN.

-- FORMULIEREN SIE DIE ABFRAGE EINMAL ALS INNERE VIEW UND EINMAL ALS
-- KONDITIONALE UNTERABFRAGE.

-- TABELLEN: SUBPROJECTS

SELECT DESCRIPTION, PROJECT_ID, FOCUS_RESEARCH
FROM SUBPROJECTS
WHERE FOCUS_RESEARCH = (SELECT MAX(FOCUS_RESEARCH) FROM SUBPROJECTS);

SELECT DESCRIPTION, PROJECT_ID, FOCUS_RESEARCH
FROM SUBPROJECTS S
WHERE NOT EXISTS(SELECT *
                 FROM SUBPROJECTS S2
                 WHERE S.FOCUS_RESEARCH < S2.FOCUS_RESEARCH)