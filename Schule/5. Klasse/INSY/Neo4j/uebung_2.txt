-- ----------------------------------------------------------------------------- --
--  1. Beispiel) Einfache Cypher Abfragen
-- ----------------------------------------------------------------------------- --
a) Schreiben Sie Ihre Verkehrslinie auf folgende Syntax um:

WITH [
    ["Leopoldau", 21, "Floridsdorf", "Wien", "Großfeldsiedlung", 21, "Floridsdorf","Wien", "U1", 1.8, 125],
    ...
] as data
UNWIND data as row
MERGE (s:Station {name: row[0], plz: row[1], district: row[2], state: row[3]})
MERGE (s1:Station {name: row[4], plz: row[5], district: row[6], state: row[7]})
MERGE (s)-[c:SUBWAY {code: row[8], length: row[9], time: row[10]}]->(s1)-[c1:SUBWAY {code: row[8], length: row[9], time: row[10]}]->(s);


// -- -------------------------------------------------------------------------------------- --
// -- TRAMWAY: 6
// -- -------------------------------------------------------------------------------------- --
WITH [
    ["Burggasse, Stadthalle",1150, "Landstraße","Wien", "Urban-Loritz-Platz",1070, "Neubau", "Wien", "6", 0.224, 55],
    ["Urban-Loritz-Platz",1070, "Neubau", "Wien", "Westbahnhof",1070, "Neubau", "Wien", "6", 0.516, 122],
    ["Westbahnhof",1070, "Neubau", "Wien", "Mariahilfer Gürtel",1060, "Mariahilf", "Wien", "6", 0.393, 118],
    ["Mariahilfer Gürtel",1060, "Mariahilf", "Wien", "Gumpendorfer Straße",1060, "Mariahilf", "Wien", "6", 0.261, 83],
    ["Gumpendorfer Straße",1060, "Mariahilf","Wien", "Margaretengürtel",1050, "Margareten", "Wien", "6", 0.422, 115],
    ["Margaretengürtel",1050, "Margareten", "Wien",  "Arbeitergasse, Gürtel",1050, "Margareten", "Wien", "6", 0.516, 109],
    ["Arbeitergasse, Gürtel",1050, "Margareten", "Wien",  "Eichenstraße",1050, "Margareten", "Wien", "6", 0.555, 114],
    ["Eichenstraße",1050, "Margareten", "Wien",  "Matzleinsdorfer Platz",1050, "Margareten", "Wien", "6", 0.634, 121],
    ["Matzleinsdorfer Platz",1050, "Margareten", "Wien",  "Knöllgasse",1100, "Favoriten", "Wien", "6", 0.432, 102],
    ["Knöllgasse",1100, "Favoriten","Wien","Bernhardtstalgasse",1100, "Favoriten","Wien","6", 0.5, 60],
    ["Bernhardtstalgasse",1100, "Favoriten","Wien","Neilreichgasse",1100, "Favoriten","Wien","6", 1.2, 120],
    ["Neilreichgasse",1100, "Favoriten","Wien","Leebg. Siccardsburgg",1100, "Favoriten","Wien","6", 1.4, 60],
    ["Neilreichgasse",1100, "Favoriten","Wien", "Quellenplatz",1100, "Favoriten","Wien","6", 1, 60],
    ["Quellenplatz",1100, "Favoriten","Wien", "Reumannplatz",1100, "Favoriten","Wien","6", 0.3, 60],
    ["Reumannplatz",1100, "Favoriten","Wien", "Gellertplatz",1100, "Favoriten","Wien","6", 0.5, 60],
    ["Gellertplatz",1100, "Favoriten","Wien", "Schrankenberggasse",1100, "Favoriten","Wien","6", 0.5, 120],
    ["Schrankenberggasse",1100, "Favoriten","Wien", "Absberggasse",1100, "Favoriten","Wien","6", 0.4, 60],
    ["Absberggasse",1100, "Favoriten","Wien", "Geiereckstraße",1100, "Favoriten","Wien","6", 0.4, 60]
] as data
UNWIND data as row
MERGE (s:Station {name: row[0], plz: row[1], district: row[2], state: row[3]})
MERGE (s1:Station {name: row[4], plz: row[5], district: row[6], state: row[7]})
MERGE (s)-[c:TRAMWAY {code: row[8], length: row[9], time: row[10]}]->(s1)-[c1:TRAMWAY {code: row[8], length: row[9], time: row[10]}]->(s);


-- ----------------------------------------------------------------------------- --
--  2. Beispiel) Einfache Cypher Abfragen
-- ----------------------------------------------------------------------------- --

a) Finden Sie die beiden Endstationen der U2.

   Knoten: s:Station
   Kanten: SUBWAY

   Ausgabe: s.name


   CQL:
MATCH (s:Station)-[r:SUBWAY {code:"U2"}]->(:Station)
WITH s.name as NAME, count(r) AS CONNECTIONS
WHERE CONNECTIONS = 1
RETURN NAME



b) Finden Sie für jede U-Bahnlinie die beiden Endstationen.

   Knoten: s:Station
   Kanten: SUBWAY

   Ausgabe: s.name


   CQL:
MATCH (s:Station)-[r:SUBWAY]->(:Station)
WITH s.name as NAME, count(r) AS CONNECTIONS, r.code as CODE
WHERE CONNECTIONS = 1
RETURN NAME, CODE
ORDER BY CODE



c) Geben Sie alle U-Bahn Linien aus für die alle Gesamtstrecke eine
   Länge von mindestens 40 haben.


   Knoten: Station
   Kanten: r:SUBWAY

   Ausgabe: r.code


   CQL:
MATCH (s:Station)-[r:SUBWAY]->(:Station)
WITH r.code as CODE, sum(r.length) as LENGTH
WHERE LENGTH >= 40
RETURN CODE
order by CODE


-- ----------------------------------------------------------------------------- --
--  3. Beispiel) Komplexe Cypher Abfragen
-- ----------------------------------------------------------------------------- --
a) Auf der U2 kommt es aufgrund von Bauarbeiten zu Verzögerungen.
   Gehen Sie davon aus, dass die UBahn für die Teilstrecke von Rathaus
   nach Seestadt um 40% länger braucht.

   Geben Sie an wieviele Minuten die UBahn für 1 Durchfahrt braucht.

   Hinweis: Verwenden Sie die shortestPath Funktion um bei der Angabe zweier
            Knoten einen der kürzesten Pfade zwischen den Knoten zu berechnen.

            z.B.: MATCH p = shortestPath((:Station)-[:SUBWAY*]->(:Station))
                  RETURN ...

   Knoten: :Station
   Kanten: :SUBWAY

   Ausgabe: timeSpend


   CQL:

   MATCH p = shortestPath((:Station {name: "Seestadt"})-[r:SUBWAY*]->(:Station {name: "Karlsplatz"}))
RETURN p


-- ------------------------------------------------------------------------------ --
--    4.Beispiel) Komplexe Abfragen
-- ------------------------------------------------------------------------------ --
a) Finden Sie alle U-Bahnlinien die keine Teilroute haben die länger ist als 2

   Knoten: Station
   Kanten: s:SUBWAY

   Ausgabe: s.code


   CQL: match (s:Station)-[r:SUBWAY]-(:Station)
with r.code as CODE, collect(distinct r) as CONNECTIONS
where all(x in CONNECTIONS where x.length < 2)
return CODE




-- ------------------------------------------------------------------------------ --
--    5.Beispiel) apoc Abfragen
-- ------------------------------------------------------------------------------ --
a) Ermitteln Sie für jede Station den Knotengrad und speichern Sie
   sie ihn in einer Property degree.


   CQL:
   MATCH (s:Station)
WITH s as STATION, s.name as NAME, apoc.node.degree(s) AS DEGREE
CALL apoc.create.setProperty(STATION, "degree", DEGREE)
YIELD node
RETURN node.name, node.degree



b) Finden Sie für die U4 die Station mit den meisten Anbindungen

   CQL:
   MATCH (s:Station)-[r:SUBWAY {code: "U4"}]->(:Station)
WITH distinct s.name as NAME, s.degree as DEGREE
WITH max(DEGREE) as MAX_DEGREE
MATCH (s:Station)-[r:SUBWAY {code: "U4"}]->(:Station)
WITH distinct s.name as NAME, s.degree as DEGREE, MAX_DEGREE
WHERE DEGREE = MAX_DEGREE
RETURN NAME, DEGREE
